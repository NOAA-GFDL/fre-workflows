#!jinja2

{# things written between hash and single braces is a Jinja comment. #}
{# Jinja code between single braces is run.                          #}
{# Jinja code with two braces is printed.                            #}

{# The site-specific file (stored in site/ subdir) is included at the end of this file. When working in the main   #}
{# branch, the ppan site file should be specified. The ppan site comprises of gfdl specific tools. Other available #}
{# sites include ppan, gfdl-ws, and generic. The generic.cylc site file is used for a portable flow.cylc.          #}
{# (Probably, we should use similar mechanisms where sensible, e.g. for shared items among workflows)              #}
{% set SITE = SITE %}

{# Calculate the number of history segments per a-chunk #}
{% set HIST_SEGMENTS_PER_CHUNK_A = (PP_CHUNK_A | duration_as('s') / HISTORY_SEGMENT | duration_as('s')) | int %}

{# secs_per_365cal_month #}
{% set SECS_PER_365CAL_MONTH = (365 / 12 * 24 * 60 * 60) %}
{# months_per_hist_segment #}
{% set MOS_PER_HIST_SEGMENT = (HISTORY_SEGMENT | duration_as('s') / SECS_PER_365CAL_MONTH) | int %}
{# months_per_chunk_a #}
{% set MOS_PER_CHUNK_A = (PP_CHUNK_A | duration_as('s') / SECS_PER_365CAL_MONTH) | int %}


{# Calculate the number of a-chunks per b-chunk (if desired) #}
{% set DO_SECONDARY_PP = False %}
{% if PP_CHUNK_B is defined and PP_CHUNK_B != PP_CHUNK_A %}
    {% set CHUNK_AS_PER_CHUNK_B = (PP_CHUNK_B | duration_as('s') / PP_CHUNK_A | duration_as('s')) | int %}
    {% set DO_SECONDARY_PP = True %}
    {# months_per_chunk_b #}
	{% set MOS_PER_CHUNK_B = (PP_CHUNK_B | duration_as('s') / SECS_PER_365CAL_MONTH) | int %}
{% else %}
    {% set MOS_PER_CHUNK_B = -1 %}
{% endif %}

{# Set ANALYSIS_START and ANALYSIS_STOP if they do not exist #}
{% if ANALYSIS_START is not defined %}
    {% set ANALYSIS_START = PP_START %}
{% endif %}
{% if ANALYSIS_STOP is not defined %}
    {% set ANALYSIS_STOP = PP_STOP %}
{% endif %}

[meta]
    title = "Postprocessing Example 1"
    description = """
    Postprocessing example that includes Bronx-like functionality,
    """
    URL = https://gitlab.gfdl.noaa.gov/fre2/workflows/postprocessing

[scheduler]
    {# Implicit tasks are tasks without explicit runtime definitions in [runtime], often typos. #}
    {# (For prototyping and graphing, change this to True.)                                     #}
    allow implicit tasks = False

    {# Configure the directories and files to be included in the remote file installation #}
    install = app/*, bin/*, etc/*, lib/*
    UTC mode = True

[task parameters]
{# The task parameters (except for component) depend on configuration in Rose apps,                            #}
{# so custom Jinja triggers are used to form the lists. Cylc and custom Jinja triggers have these rules:       #}
{# 1. Triggers live in Jinja2Filters/ and must be python                                       #}
{# 2. The trigger filename must be <trigger-name>.py                                           #}
{# 3. In the file, trigger must be defined as a function with the same name                    #}
{# 4. First argument is passed through as a pipe, and the rest are passed through in the trigger arguments.    #}
{# More info:                                                      #}
{# The python loaded within Cylc has access to some useful Cylc utilities (e.g. metomi.isodatetime.parsers).   #}
{# For development/testing, use "module load conda; conda activate cylc". Then the Cylc python will be loaded. #}
{% set REGRID  =  "regrid-xy" | form_task_parameters('temporal', PP_COMPONENTS) %}
{% set REGRID_STATIC  =  "regrid-xy" | form_task_parameters('static', PP_COMPONENTS) %}
{% set DO_REGRID = REGRID|length %}
{% if DO_REGRID %}
    regrid = {{ REGRID }}
    {% if DO_STATICS %}
    regrid_static = {{ REGRID_STATIC }}
    {% endif %}
{% endif %}

{% set NATIVE  =  "native" | form_task_parameters('temporal', PP_COMPONENTS) %}
{% set NATIVE_STATIC  =  "native" | form_task_parameters('static', PP_COMPONENTS) %}
{% set DO_NATIVE = NATIVE|length %}
{% if DO_NATIVE %}
    native = {{ NATIVE }}
    {% if DO_STATICS %}
    native_static = {{ NATIVE_STATIC }}
    {% endif %}
{% endif %}

    {# Standard Jinja2 triggers are also available (e.g. "replace") #}
    component = {{ PP_COMPONENTS | replace(' ', ', ') }}



[scheduling]
    initial cycle point = {{ PP_START }}
    final cycle point = {{ PP_STOP }}
    # max number of active cycle points (default 5)
    # this should be something sensible assuming tasks with required outputs
    # (i.e. not marked as "ok to fail") such as analysis scripts.
    # But until the analysis scripts can be marked optional then let's
    # set this to be very high, 100 cycle points.
    runahead limit = P100
    [[queues]]
        # limit the entire workflow to 50 active tasks at once
        [[[default]]]
            limit = 50
    {# Graph strings are organized by recurrence interval-- when to run the tasks.    #}
    {# Currently, we use 4 intervals: every history-file segment, once (for statics), #}
    {# every chunk-a, and every chunk-b.                                              #}
    [[graph]]
{% if DO_ANALYSIS_ONLY %}
    {% if DO_SECONDARY_PP %}
{{ 'per-interval-task-graph' | get_analysis_info(PP_COMPONENTS, PP_DIR, PP_START, PP_STOP, ANALYSIS_START, ANALYSIS_STOP, PP_CHUNK_B, DO_ANALYSIS_ONLY) }}
{{ 'cumulative-task-graph' | get_analysis_info(PP_COMPONENTS, PP_DIR, PP_START, PP_STOP, ANALYSIS_START, ANALYSIS_STOP, PP_CHUNK_B, DO_ANALYSIS_ONLY) }}
{{ 'defined-interval-task-graph' | get_analysis_info(PP_COMPONENTS, PP_DIR, PP_START, PP_STOP, ANALYSIS_START, ANALYSIS_STOP, PP_CHUNK_B, DO_ANALYSIS_ONLY) }}
    {% else %}
{{ 'per-interval-task-graph' | get_analysis_info(PP_COMPONENTS, PP_DIR, PP_START, PP_STOP, ANALYSIS_START, ANALYSIS_STOP, PP_CHUNK_A, DO_ANALYSIS_ONLY) }}
{{ 'cumulative-task-graph' | get_analysis_info(PP_COMPONENTS, PP_DIR, PP_START, PP_STOP, ANALYSIS_START, ANALYSIS_STOP, PP_CHUNK_A, DO_ANALYSIS_ONLY) }}
{{ 'defined-interval-task-graph' | get_analysis_info(PP_COMPONENTS, PP_DIR, PP_START, PP_STOP, ANALYSIS_START, ANALYSIS_STOP, PP_CHUNK_A, DO_ANALYSIS_ONLY) }}
    {% endif %}
{% else %}
        #
        # Recurrence interval: every history-file segment
        #
        {{ HISTORY_SEGMENT }} = """
{# Within a recurrence interval, task dependencies are specified with => (depends on), & (and), and | (or). #}
{# Tasks in a dependency can be single tasks, task families (by convention, in all caps),           #}
{# or "ensembles" expanded by the parameters above.                                                         #}

{# All tasks in the STAGE-HISTORY family (staging history and staging history-refined) are started #}
{# once the pp-starter task succeeds.                                                              #}
pp-starter => STAGE-HISTORY

{# Jinja is useful to include or exclude parts of the configuration. In this case, the lines between              #}
{# if DO_REFINEDIAG and endif are used or not used, depending on the value of DO_REFINEDIAG (in rose-suite.conf). #}
{# All template variables in rose-suite.conf are available as Jinja variables.                    #}
{# If refineDiag generation is desired (DO_REFINEDIAG is True), then add these two task dependencies:         #}
{# 1. All tasks in the REFINE-DIAG task family are started once the stage-history task succeeds.          #}
{# 2. stage-history-refined task is started once all the refineDiag tasks succeed.                                #}
{% if DO_REFINEDIAG %}
stage-history => REFINE-DIAG
REFINE-DIAG:succeed-all => stage-history-refined
{% endif %}

{# If preAnalysis desired (vitals calculations is canonical case), #}
{# start all PRE-ANALYSIS tasks when stage-history succeeds. #}
{% if DO_PREANALYSIS %}
stage-history => PRE-ANALYSIS
{% endif %}

{# If task families are on the left side of the => then a qualifier must be used (e.g. :succeed-all)     #}
{# The angle brackets define the "ensemble" axis, the task paramaters defined above.                     #}
{# The next two lines set the major processing for the native and regrid  #}
{# (horizontal regridding) lists of history files. #}
{# Each history file to be regridded should be regridded once staging is done; then should be split and cataloged    #}
{# (into a standard shards directory set by ISO8601 frequencies ).                       #}
{# Each history file needed for native grid processing is similar, except skipping the regridding.         #}
{% if DO_REGRID %}
STAGE-HISTORY:succeed-all => regrid-xy<regrid> => split-netcdf-regrid<regrid> => rename-split-to-pp-regrid<regrid>
    {% if DO_ATMOS_PLEVEL_MASKING %}
STAGE-HISTORY:succeed-all => mask-atmos-plevel<regrid> => regrid-xy<regrid>
    {% endif %}
{% endif %}

{% if DO_NATIVE %}
STAGE-HISTORY:succeed-all => split-netcdf-native<native> => rename-split-to-pp-native<native>
    {% if DO_ATMOS_PLEVEL_MASKING %}
STAGE-HISTORY:succeed-all => mask-atmos-plevel<native> => split-netcdf-native<native>
    {% endif %}
{% endif %}

{# If HISTORY_DIR_REFINED is set, then use the next 3 lines.              #}
{# Regridding and splitting native history files should not start until the history-refined output is available.   #}
{% if HISTORY_DIR_REFINED is defined %}
    {% if DO_REGRID %}
stage-history-refined => regrid-xy<regrid>
    {% endif %}
    {% if DO_NATIVE %}
stage-history-refined => split-netcdf-native<native>
    {% endif %}
{% endif %}

{# If work-dir cleaning is desired, then remove what should now be safe to remove.                                 #}
{# Once regridded history files are split, then the regridded history files can be removed.            #}
{# Once the split (regridded and native) files are cataloged, then the (not-cataloged) split files can be removed. #}
{% if CLEAN_WORK %}
    {% if DO_REGRID %}
regrid-xy<regrid>                 => clean-history-native
split-netcdf-regrid<regrid>       => clean-history-regrid-xy
rename-split-to-pp-regrid<regrid> => clean-split-regrid-xy
    {% endif %}
    {% if DO_NATIVE %}
split-netcdf-native<native>       => clean-history-native
rename-split-to-pp-native<native> => clean-split-native
    {% endif %}
{% endif %}
"""


        #
        # Recurrence interval R1: run only once. useful for statics.
        #
        R1 = """
{# The static processing is similar to the "every history segment" processing, #}
{# except uses different history file lists. #}
pp-starter => STAGE-HISTORY
{% if DO_STATICS %}
    {% if DO_REGRID %}
STAGE-HISTORY:succeed-all => regrid-xy<regrid_static> => split-netcdf-regrid<regrid_static> => rename-split-to-pp-regrid<regrid_static>
    {% endif %}
    {% if DO_NATIVE %}
STAGE-HISTORY:succeed-all =>                             split-netcdf-native<native_static> => rename-split-to-pp-native<native_static>
    {% endif %}
{# After cataloging the regridded and native statics, remap them to pp components as desired #}
    {% if DO_NATIVE and DO_REGRID %}
rename-split-to-pp-regrid<regrid_static> & rename-split-to-pp-native<native_static> => remap-pp-components-static => combine-statics
    {% elif DO_NATIVE %}
rename-split-to-pp-native<native_static> => remap-pp-components-static => combine-statics
    {% elif DO_REGRID %}
rename-split-to-pp-regrid<regrid_static> => remap-pp-components-static => combine-statics
    {% endif %}
{% endif %}

{# Similarly, if the history-refined is used, then don't process until the history-refined staging is done. #}
{% if HISTORY_DIR_REFINED is defined %}
    {% if DO_STATICS %}
        {% if DO_REGRID %}
stage-history-refined => regrid-xy<regrid_static>
        {% endif %}
        {% if DO_NATIVE %}
stage-history-refined => split-netcdf-native<native_static>
        {% endif %}
    {% endif %}
{% endif %}

{# If work-dir cleaning is set, then remove what should now be safe to remove. #}
{% if CLEAN_WORK and DO_STATICS %}
    {% if DO_REGRID %}
regrid-xy<regrid_static> => clean-history-native
split-netcdf-regrid<regrid_static> => clean-history-regrid-xy
rename-split-to-pp-regrid<regrid_static> => clean-split-regrid-xy
    {% endif %}
    {% if DO_NATIVE %}
split-netcdf-native<native_static> => clean-history-native
rename-split-to-pp-native<native_static> => clean-split-native
    {% endif %}
remap-pp-components-static => clean-shards-static
combine-statics => clean-pp-statics
{% endif %}
"""


        #
        # Recurrence interval: every CHUNK-A
        #
        {# Run the tasks to process CHUNK-A every CHUNK-A, starting after PP_CHUNK_A #}
        +{{ PP_CHUNK_A | subtract_durations(HISTORY_SEGMENT) }}/{{ PP_CHUNK_A }} = """

{# Tasks can be split over multiple lines if the subsequent ones begin with =>, &, or |                   #}
{# The make-timeseries tasks for CHUNK-A depend on all segment processing for the time period succeeding. #}
{# This Jinja for loop expands to do this.                                                                #}
{% if DO_REGRID %}
rename-split-to-pp-regrid<regrid>
    {% for SEGMENT in range(1, HIST_SEGMENTS_PER_CHUNK_A) %}
& rename-split-to-pp-regrid<regrid>[{{ HISTORY_SEGMENT | multiply_duration(-SEGMENT) }}]
    {% endfor %}
    {% if HISTORY_SEGMENT != PP_CHUNK_A %}
=> make-timeseries-regrid-{{ PP_CHUNK_A }}<regrid>
    {% endif %}
    {% if DO_TIMEAVGS %}
=> make-timeavgs-regrid-{{ PP_CHUNK_A }}<regrid>
    {% endif %}
{% endif %}

{% if DO_NATIVE %}
rename-split-to-pp-native<native>
    {% for SEGMENT in range(1, HIST_SEGMENTS_PER_CHUNK_A) %}
& rename-split-to-pp-native<native>[{{ HISTORY_SEGMENT | multiply_duration(-SEGMENT) }}]
    {% endfor %}
    {% if HISTORY_SEGMENT != PP_CHUNK_A %}
=> make-timeseries-native-{{ PP_CHUNK_A }}<native>
    {% endif %}
    {% if DO_TIMEAVGS %}
=> make-timeavgs-native-{{ PP_CHUNK_A }}<native>
    {% endif %}
{% endif %}

{% if DO_REGRID %}
{{ "regrid-xy" | form_remap_dep('temporal', PP_CHUNK_A, PP_COMPONENTS, 'ts', HISTORY_SEGMENT) }}
    {% if DO_TIMEAVGS %}
{{ "regrid-xy" | form_remap_dep('temporal', PP_CHUNK_A, PP_COMPONENTS, 'av', HISTORY_SEGMENT) }}
    {% endif %}
{% endif %}

{% if DO_NATIVE %}
{{ "native" | form_remap_dep('temporal', PP_CHUNK_A, PP_COMPONENTS, 'ts', HISTORY_SEGMENT) }}
    {% if DO_TIMEAVGS %}
{{ "native" | form_remap_dep('temporal', PP_CHUNK_A, PP_COMPONENTS, 'av', HISTORY_SEGMENT) }}
    {% endif %}
{% endif %}

{% if DO_TIMEAVGS %}
remap-pp-components-av-{{ PP_CHUNK_A }}<component> => combine-timeavgs-{{ PP_CHUNK_A }}<component>
    {% if CLEAN_WORK %}
COMBINE-TIMEAVGS-{{ PP_CHUNK_A }}:succeed-all => clean-pp-timeavgs-{{ PP_CHUNK_A }}
    {% endif %}
{% endif %}

# 3 scenarios of CHUNK-A workdir cleaning
# 1. If secondary chunk is not used, then remove history and chunk-a shards after remapping ts and av
# 2. If chunk-a equals history segment, then do nothing- these will be removed after chunk-b generation
# 3. Otherwise, remove prereq history segments and leave the chunk-a shards for chunk-b generation
{% if CLEAN_WORK %}
    {% if PP_CHUNK_B is not defined or PP_CHUNK_A != HISTORY_SEGMENT %}
REMAP-PP-COMPONENTS-TS-{{ PP_CHUNK_A }}:succeed-all => clean-shards-{{ HISTORY_SEGMENT }}
        {% if DO_TIMEAVGS %}
REMAP-PP-COMPONENTS-AV-{{ PP_CHUNK_A }}:succeed-all => clean-shards-{{ HISTORY_SEGMENT }}
        {% endif %}
    {% endif %}
{% endif %}

{# If MDTF is requested, then run it after all pp components have finished #}
{% if DO_MDTF %}
REMAP-PP-COMPONENTS-TS-{{ PP_CHUNK_A }}:succeed-all => mdtf
{% endif %}

REMAP-PP-COMPONENTS-TS-{{ PP_CHUNK_A }}:succeed-all => data-catalog?
"""


#
# Recurrence interval: every CHUNK-B
#
{# If only one pp chunk is used, then skip the CHUNK-B processing. #}
{% if DO_SECONDARY_PP %}
        {# Run the tasks to process CHUNK-B every CHUNK-B, starting after CHUNK-B time #}
        +{{ PP_CHUNK_B | subtract_durations(HISTORY_SEGMENT) }}/{{ PP_CHUNK_B }} = """

{# The make-timeseries tasks for CHUNK-B depend on all CHUNK-A processing for the time period succeeding. #}
    {% if DO_REGRID %}
        {% if HISTORY_SEGMENT == PP_CHUNK_A %}
rename-split-to-pp-regrid<regrid>
        {% else %}
make-timeseries-regrid-{{ PP_CHUNK_A }}<regrid>
        {% endif %}
        {% for CHUNK in range(1, CHUNK_AS_PER_CHUNK_B) %}
        {% if HISTORY_SEGMENT == PP_CHUNK_A %}
& rename-split-to-pp-regrid<regrid>[{{ PP_CHUNK_A | multiply_duration(-CHUNK)}}]
        {% else %}
& make-timeseries-regrid-{{ PP_CHUNK_A }}<regrid>[{{ PP_CHUNK_A | multiply_duration(-CHUNK)}}]
        {% endif %}
        {% endfor %}
=> make-timeseries-regrid-{{ PP_CHUNK_B }}<regrid>
        {% if DO_TIMEAVGS %}
=> make-timeavgs-regrid-{{ PP_CHUNK_B }}<regrid>
        {% endif %}
    {% endif %}

    {% if DO_NATIVE %}
        {% if HISTORY_SEGMENT == PP_CHUNK_A %}
rename-split-to-pp-native<native>
        {% else %}
make-timeseries-native-{{ PP_CHUNK_A }}<native>
        {% endif %}
        {% for CHUNK in range(1, CHUNK_AS_PER_CHUNK_B) %}
        {% if HISTORY_SEGMENT == PP_CHUNK_A %}
& rename-split-to-pp-native<native>[{{ PP_CHUNK_A | multiply_duration(-CHUNK)}}]
        {% else %}
& make-timeseries-native-{{ PP_CHUNK_A }}<native>[{{ PP_CHUNK_A | multiply_duration(-CHUNK)}}]
        {% endif %}
        {% endfor %}
=> make-timeseries-native-{{ PP_CHUNK_B }}<native>
        {% if DO_TIMEAVGS %}
=> make-timeavgs-native-{{ PP_CHUNK_B }}<native>
        {% endif %}
    {% endif %}

    {% if DO_TIMEAVGS %}
remap-pp-components-av-{{ PP_CHUNK_B }}<component> => combine-timeavgs-{{ PP_CHUNK_B }}<component>
        {% if CLEAN_WORK %}
COMBINE-TIMEAVGS-{{ PP_CHUNK_B }}:succeed-all => clean-pp-timeavgs-{{ PP_CHUNK_B }}
        {% endif %}
    {% endif %}

{# Generate the per-component make-timeseries => remap-pp-component tasks using Jinja trigger form_remap_dep #}
{# Throw validation exception if PP_CHUNK_B is not in rose-app.conf                                          #}
    {% if DO_REGRID %}
{{ "regrid-xy" | form_remap_dep('temporal', PP_CHUNK_B, PP_COMPONENTS, 'ts') }}
        {% if DO_TIMEAVGS %}
{{ "regrid-xy" | form_remap_dep('temporal', PP_CHUNK_B, PP_COMPONENTS, 'av') }}
        {% endif %}
    {% endif %}

    {% if DO_NATIVE %}
{{ "native" | form_remap_dep('temporal', PP_CHUNK_B, PP_COMPONENTS, 'ts') }}
        {% if DO_TIMEAVGS %}
{{ "native" | form_remap_dep('temporal', PP_CHUNK_B, PP_COMPONENTS, 'av') }}
        {% endif %}
    {% endif %}

# CHUNK-B work dir cleaning: remove CHUNK-A and CHUNK-B shards after saving the CHUNK-B products
    {% if CLEAN_WORK %}
REMAP-PP-COMPONENTS-TS-{{ PP_CHUNK_B }}:succeed-all => clean-shards-{{ PP_CHUNK_B }}
        {% if DO_TIMEAVGS %}
REMAP-PP-COMPONENTS-AV-{{ PP_CHUNK_B }}:succeed-all => clean-shards-{{ PP_CHUNK_B }}
        {% endif %}
REMAP-PP-COMPONENTS-TS-{{ PP_CHUNK_B }}:succeed-all => clean-shards-{{ PP_CHUNK_A }}
        {% if DO_TIMEAVGS %}
REMAP-PP-COMPONENTS-AV-{{ PP_CHUNK_B }}:succeed-all => clean-shards-{{ PP_CHUNK_A }}
        {% endif %}
    {% endif %}
"""
{% endif %}

#
# Recurrence intervals for analysis tasks
#
    {% if DO_ANALYSIS %}
        {% if DO_SECONDARY_PP %}
{{ 'per-interval-task-graph' | get_analysis_info(PP_COMPONENTS, PP_DIR, PP_START, PP_STOP, ANALYSIS_START, ANALYSIS_STOP, PP_CHUNK_B, DO_ANALYSIS_ONLY) }}
{{ 'cumulative-task-graph' | get_analysis_info(PP_COMPONENTS, PP_DIR, PP_START, PP_STOP, ANALYSIS_START, ANALYSIS_STOP, PP_CHUNK_B, DO_ANALYSIS_ONLY) }}
{{ 'defined-interval-task-graph' | get_analysis_info(PP_COMPONENTS, PP_DIR, PP_START, PP_STOP, ANALYSIS_START, ANALYSIS_STOP, PP_CHUNK_B, DO_ANALYSIS_ONLY) }}
        {% else %}
{{ 'per-interval-task-graph' | get_analysis_info(PP_COMPONENTS, PP_DIR, PP_START, PP_STOP, ANALYSIS_START, ANALYSIS_STOP, PP_CHUNK_A, DO_ANALYSIS_ONLY) }}
{{ 'cumulative-task-graph' | get_analysis_info(PP_COMPONENTS, PP_DIR, PP_START, PP_STOP, ANALYSIS_START, ANALYSIS_STOP, PP_CHUNK_A, DO_ANALYSIS_ONLY) }}
{{ 'defined-interval-task-graph' | get_analysis_info(PP_COMPONENTS, PP_DIR, PP_START, PP_STOP, ANALYSIS_START, ANALYSIS_STOP, PP_CHUNK_A, DO_ANALYSIS_ONLY) }}
        {% endif %}
    {% endif %}

{% endif %}

[runtime]
    [[pp-starter]]
        inherit = PP-STARTER
        # NOTE! script must appear *before* [[[enviroment]]] or else
        # the job scripts will have quoting issues
        script = """
            # Returns 0 if ready, 1 if not
            #
            echo Arguments:
            echo "    INFO: trigger: $targetFile"
            echo "    INFO: cycle point: $CYLC_TASK_CYCLE_POINT"
            # Resolve the date strings: YYYY, MM, DD, HH
            IFS='-' read YYYY MM DD << DATES
            $(cylc cycle-point --template CCYY-MM-DD)
            DATES
            HH=$(cylc cycle-point --template hh)
            targetFileResolved=$(echo $targetFile | sed -e "s/YYYY/$YYYY/g" -e "s/MM/$MM/g" -e "s/DD/$DD/g" -e "s/HH/$HH/g")
            echo "    trigger (date expanded): $targetFileResolved"
            # Look for target file
            if ls $targetFileResolved; then
                echo "Target ${targetFileResolved} is ready"
                exit 0
            else
                echo "Error: target ${targetFileResolved} is not ready"
                exit 1
            fi
        """
        [[[environment]]]
            targetFile = {{ HISTORY_DIR }}/YYYYMMDD.nc.tar

    [[STAGE-HISTORY]]
        # Increase time limit for staging jobs to 8 hours
        execution time limit = PT8H
        script = """
            set -euo pipefail

            #Stage the contents of a tarfile to PTMP
            echo Arguments:
            echo "    history dir: $historyDir"
            echo "    ptmp dir: $ptmpDir"
            echo "    cycle point: $CYLC_TASK_CYCLE_POINT"
            echo "    TMPDIR (not used yet): ${TMPDIR:=/tmp}"
            echo Utilities:
            type hsmget
            type cylc
            #Verify history directory exists and is a directory
            if [[ ! -d $historyDir ]]; then
                 echo "Error: Archive directory ${historyDir} does not exist or isnt a directory"
                 exit 1
            fi
            #Verify history file exists
            file=$historyDir/$(cylc cycle-point --template CCYYMMDD).nc.tar
            if ls ${file}; then
                 echo "Going to stage ${file} to PTMP"
            else
                 echo "Error: Could not locate ${file}"
                 exit 1
            fi
            #We want to stage the history files to PTMP without transferring to VFTMP.
            #Calling hsmget on a file with wildcards that doesnt exist does this,
            #e.g. "dummy*" as below, but prints a warning
            if hsmget -v -t -a $historyDir -p $ptmpDir$historyDir -w $TMPDIR$historyDir $(basename -s .tar $file)/dummy\*; then
                 echo "History files in ${file} have been staged to PTMP successfully"
            else
                 echo "Error: Cant stage history files in ${file} to PTMP"
                 exit 1
            fi

            # Setup PYTHONPATH and io lists for the data lineage tool
            if [ ! -z "${EPMT_DATA_LINEAGE+x}" ] && [ "$EPMT_DATA_LINEAGE" == "1" ]; then
                export PYTHONPATH=$CYLC_SUITE_DEF_PATH:$PYTHONPATH
                export input_file_list=
                export output_file_list=
                echo "Set PYTHONPATH and created i/o lists"
            fi

            # Finally, link these files to $CYLC_WORKFLOW_SHARE_DIR
            mkdir -p $CYLC_WORKFLOW_SHARE_DIR/cycle/$CYLC_TASK_CYCLE_POINT/history/native
            cd $CYLC_WORKFLOW_SHARE_DIR/cycle/$CYLC_TASK_CYCLE_POINT/history/native
            ln -f $ptmpDir/$historyDir/$(cylc cycle-point --template CCYYMMDD).nc/* . \
                || ln -sf $ptmpDir/$historyDir/$(cylc cycle-point --template CCYYMMDD).nc/* .

            if [ ! -z "${EPMT_DATA_LINEAGE+x}" ] && [ "$EPMT_DATA_LINEAGE" == "1" ]; then
                outputDir=$CYLC_WORKFLOW_SHARE_DIR/cycle/$CYLC_TASK_CYCLE_POINT/history/native

                start_time=$(date +%s)

                for file in $(ls $outputDir); do
                    hash_val=$(/home/Cole.Harvey/.conda/envs/bloom-filter-env/bin/python \
                    -m data_lineage.bloomfilter.HashGen $outputDir/$file)
                    export output_file_list="${output_file_list}$file $hash_val,"
                    echo "[DATA LINEAGE] Added $file to output list with hash_val: $hash_val"
                done

                end_time=$(date +%s)
                duration=$((end_time - start_time))
                echo "Time spent hashing and creating the file list: $duration seconds"

                epmt -v annotate EPMT_DATA_LINEAGE_OUT_PATH="$outputDir/"
                echo "[DATA LINEAGE] Annotated $outputDir/ to EPMT_DATA_LINEAGE_OUT_PATH"

                if [ -n "$output_file_list" ]; then
                    compressed_bytes=$(/home/Cole.Harvey/.conda/envs/bloom-filter-env/bin/python \
                    -m data_lineage.bloomfilter.StringCompression "${output_file_list}")
                    epmt -v annotate EPMT_DATA_LINEAGE_OUT="${compressed_bytes%*,}"
                    echo "[DATA LINEAGE] Annotated output files to EPMT_LINEAGE_OUT"
                fi
            fi

            echo "Natural end of the history file staging"
            exit 0
        """
    [[stage-history]]
        inherit = STAGE-HISTORY
        [[[environment]]]
            historyDir = {{ HISTORY_DIR }}
            ptmpDir = {{ PTMP_DIR }}


{% if HISTORY_DIR_REFINED is defined %}
    [[stage-history-refined]]
        inherit = STAGE-HISTORY
        post-script = """
        """
        [[[environment]]]
            historyDir = {{ HISTORY_DIR_REFINED }}
            ptmpDir = {{ PTMP_DIR }}

{% endif %}

{% if DO_TIMEAVGS %}
    [[MAKE-TIMEAVGS]]
        pre-script = mkdir -p $outputDir
        script = rose task-run --verbose --app-key make-timeavgs
    {% if DO_NATIVE %}
    [[MAKE-TIMEAVGS-NATIVE]]
        [[[environment]]]
            inputDir = $CYLC_WORKFLOW_SHARE_DIR/shards/ts/native
            outputDir = $CYLC_WORKFLOW_SHARE_DIR/shards/av/native
            component = $CYLC_TASK_PARAM_native
    {% endif %}
    {% if DO_REGRID %}
    [[MAKE-TIMEAVGS-REGRID]]
        [[[environment]]]
            inputDir = $CYLC_WORKFLOW_SHARE_DIR/shards/ts/regrid-xy
            outputDir = $CYLC_WORKFLOW_SHARE_DIR/shards/av/regrid-xy
            component = $CYLC_TASK_PARAM_regrid
            use_subdirs = 1
    {% endif %}
    [[MAKE-TIMEAVGS-{{ PP_CHUNK_A }}]]
        [[[environment]]]
            interval = {{ PP_CHUNK_A }}
    {% if DO_NATIVE %}
    [[MAKE-TIMEAVGS-NATIVE-{{ PP_CHUNK_A }}]]
        inherit = MAKE-TIMEAVGS, MAKE-TIMEAVGS-NATIVE, MAKE-TIMEAVGS-{{ PP_CHUNK_A }}
    [[make-timeavgs-native-{{ PP_CHUNK_A }}<native>]]
        inherit = MAKE-TIMEAVGS-NATIVE-{{ PP_CHUNK_A }}, <native>
    {% endif %}
    {% if DO_REGRID %}
    [[MAKE-TIMEAVGS-REGRID-{{ PP_CHUNK_A }}]]
        inherit = MAKE-TIMEAVGS, MAKE-TIMEAVGS-REGRID, MAKE-TIMEAVGS-{{ PP_CHUNK_A }}
    [[make-timeavgs-regrid-{{ PP_CHUNK_A }}<regrid>]]
        inherit = MAKE-TIMEAVGS-REGRID-{{ PP_CHUNK_A }}, <regrid>
    {% endif %}
    {% if DO_SECONDARY_PP %}
    [[MAKE-TIMEAVGS-{{ PP_CHUNK_B }}]]
        [[[environment]]]
            interval = {{ PP_CHUNK_B }}
        {% if DO_NATIVE %}
    [[MAKE-TIMEAVGS-NATIVE-{{ PP_CHUNK_B }}]]
        inherit = MAKE-TIMEAVGS, MAKE-TIMEAVGS-NATIVE, MAKE-TIMEAVGS-{{ PP_CHUNK_B }}
    [[make-timeavgs-native-{{ PP_CHUNK_B }}<native>]]
        inherit = MAKE-TIMEAVGS-NATIVE-{{ PP_CHUNK_B }}, <native>
        {% endif %}
        {% if DO_REGRID %}
    [[MAKE-TIMEAVGS-REGRID-{{ PP_CHUNK_B }}]]
        inherit = MAKE-TIMEAVGS, MAKE-TIMEAVGS-REGRID, MAKE-TIMEAVGS-{{ PP_CHUNK_B }}
    [[make-timeavgs-regrid-{{ PP_CHUNK_B }}<regrid>]]
        inherit = MAKE-TIMEAVGS-REGRID-{{ PP_CHUNK_B }}, <regrid>
        {% endif %}
    {% endif %}
{% endif %}

{% if DO_REFINEDIAG or DO_PREANALYSIS %}
    [[PRE-ANALYSIS]]
        pre-script = """
            env
            set -x
            mkdir -p $work $tempCache $refineDiagDir
            cd $work/$hsmdate
            ls
        """
        [[[environment]]]
            name = {{ EXPERIMENT }}
            rtsxml = no-more-xml
            work = $TMPDIR/work
            tempCache = $TMPDIR/tempCache
            root = $CYLC_WORKFLOW_RUN_DIR
            archive = is-this-needed
            scriptName = $CYLC_TASK_LOG_DIR/job
            oname = $(cylc cycle-point --template CCYYMMDD)
            hsmdate = $oname.nc
            ptmpDir = {{ PTMP_DIR }}/{{ HISTORY_DIR }}
            histDir = {{ HISTORY_DIR }}
            platform = {{ PLATFORM }}
            target = {{ TARGET }}
            segment_months = {{ HISTORY_SEGMENT }}
            basedate = is-this-needed
            gridspec = {{ PP_GRID_SPEC }}
            refineDiagDir = $TMPDIR/history_refineDiag/$hsmdate
            catalog = {{ PP_DIR }}/catalog.json
{% endif %}
{% if DO_REFINEDIAG %}
    [[REFINE-DIAG]]
        inherit = PRE-ANALYSIS
        post-script = """
            cd $refineDiagDir
            if ls *nc; then
                refinedCount=$(ls -1 *nc | wc -l)
            else
                refinedCount=0
            fi
            if [[ $refinedCount > 0 ]]; then
                for file in $(ls -1 *nc); do
                    list_ncvars.csh -st01234 $file |& tee $CYLC_WORKFLOW_SHARE_DIR/refineDiag.log
                done
            else
                echo ERROR: RefineDiag script did not create any NetCDF files as it was expected to do
                exit 1
            fi
            if [[ -f {{ HISTORY_DIR_REFINED }}/$oname.nc.tar ]]; then
                echo "the contents of {{ PTMP_DIR }}/{{ HISTORY_DIR_REFINED }} is..."
                ls {{ PTMP_DIR }}/{{ HISTORY_DIR_REFINED }}
                echo "the contents of {{ PTMP_DIR }}/{{ HISTORY_DIR_REFINED }}/$oname.nc is..."
                ls {{ PTMP_DIR }}/{{ HISTORY_DIR_REFINED }}/$oname.nc
                mv -f * $TMPDIR/modify_refineDiag
                mv -f $TMPDIR/modify_refineDiag/* .
                rm -rf $TMPDIR/modify_refineDiag
            fi
        """
{# The following section executes refineDiag tasks, whether single or multiple refineDiag paths are given #}
{# Create a 'macro' function to reduce code repeat #}
    {% macro exec_refine(script_name) -%}
            inherit = REFINE-DIAG
            script = """
                ls
                echo NOTE: About to source user script
                if csh {{ script_name }}; then
                    echo NOTE: User script exited normally
                else
                    echo ERROR: User script got an error status $?
                    exit 1
                fi
            """
    {%- endmacro %}
{# Use the 'split' function to transform string into an iterable list, including of length 1 #}
    {% set refineDiag_scripts = REFINEDIAG_SCRIPTS.split(' ') %}
    {% for refineDiag_path in refineDiag_scripts %}
            [[refineDiag-{{ refineDiag_path[refineDiag_path.rfind('/')+1:refineDiag_path.rfind('.')] | replace(".", "_") }}]]
        {{ exec_refine(refineDiag_path) }}
    {% endfor %}
{% endif %}

{% if DO_PREANALYSIS and PREANALYSIS_SCRIPT is defined %}
    {% set preanalysis_name = PREANALYSIS_SCRIPT[PREANALYSIS_SCRIPT.rfind('/')+1:PREANALYSIS_SCRIPT.rfind('.')] | replace(".", "_") %}
    [[preAnalysis-{{ preanalysis_name }}]]
        inherit = PRE-ANALYSIS
        script = """
            ls
            echo NOTE: About to source user script
            if csh {{ PREANALYSIS_SCRIPT }}; then
                echo NOTE: User script exited normally
            else
                echo ERROR: User script got an error status $?
                exit 1
            fi
        """
{% endif %}

    [[MASK-ATMOS-PLEVEL]]
        script = rose task-run --verbose --app-key mask-atmos-plevel
        [[[environment]]]
            inputDir = $CYLC_WORKFLOW_SHARE_DIR/cycle/$CYLC_TASK_CYCLE_POINT/history/native
{% if DO_NATIVE %}
    [[mask-atmos-plevel<native>]]
        inherit = MASK-ATMOS-PLEVEL, <native>
        [[[environment]]]
            component = $CYLC_TASK_PARAM_native
{% endif %}
{% if DO_REGRID %}
    [[mask-atmos-plevel<regrid>]]
        inherit = MASK-ATMOS-PLEVEL, <regrid>
        [[[environment]]]
            component = $CYLC_TASK_PARAM_regrid
{% endif %}

    [[SPLIT-NETCDF]]
        pre-script = mkdir -p $outputDir
        script = rose task-run --verbose --app-key split-netcdf
        [[[environment]]]
            date = $CYLC_TASK_CYCLE_POINT

{% if DO_NATIVE %}
    [[SPLIT-NETCDF-NATIVE]]
        inherit = SPLIT-NETCDF
        [[[environment]]]
            inputDir = $CYLC_WORKFLOW_SHARE_DIR/cycle/$CYLC_TASK_CYCLE_POINT/history/native
            outputDir = $CYLC_WORKFLOW_SHARE_DIR/cycle/$CYLC_TASK_CYCLE_POINT/split/native
            component = $CYLC_TASK_PARAM_native
{% endif %}

{% if DO_REGRID %}
    [[SPLIT-NETCDF-REGRID]]
        inherit = SPLIT-NETCDF
        [[[environment]]]
            inputDir = $CYLC_WORKFLOW_SHARE_DIR/cycle/$CYLC_TASK_CYCLE_POINT/history/regrid-xy
            outputDir = $CYLC_WORKFLOW_SHARE_DIR/cycle/$CYLC_TASK_CYCLE_POINT/split/regrid-xy
            use_subdirs = 1
            component = $CYLC_TASK_PARAM_regrid
{% endif %}

{% if DO_NATIVE %}
    [[split-netcdf-native<native>]]
        inherit = SPLIT-NETCDF-NATIVE, <native>
    {% if DO_STATICS %}
    [[split-netcdf-native<native_static>]]
        inherit = SPLIT-NETCDF-NATIVE, <native_static>
        [[[environment]]]
            component = $CYLC_TASK_PARAM_native_static
    {% endif %}
{% endif %}

{% if DO_REGRID %}
    [[split-netcdf-regrid<regrid>]]
        inherit = SPLIT-NETCDF-REGRID, <regrid>
    {% if DO_STATICS %}
    [[split-netcdf-regrid<regrid_static>]]
        inherit = SPLIT-NETCDF-REGRID, <regrid_static>
        [[[environment]]]
            component = $CYLC_TASK_PARAM_regrid_static

    {% endif %}
{% endif %}

    [[RENAME-SPLIT-TO-PP]]
        pre-script = mkdir -p $outputDir
        script = rose task-run --verbose --app-key rename-split-to-pp

{% if DO_NATIVE %}
    [[RENAME-SPLIT-TO-PP-NATIVE]]
        inherit = RENAME-SPLIT-TO-PP
        [[[environment]]]
            inputDir = $CYLC_WORKFLOW_SHARE_DIR/cycle/$CYLC_TASK_CYCLE_POINT/split/native
            outputDir = $CYLC_WORKFLOW_SHARE_DIR/shards/ts/native
            component = $CYLC_TASK_PARAM_native
{% endif %}

{% if DO_REGRID %}
    [[RENAME-SPLIT-TO-PP-REGRID]]
        inherit = RENAME-SPLIT-TO-PP
        [[[environment]]]
            inputDir = $CYLC_WORKFLOW_SHARE_DIR/cycle/$CYLC_TASK_CYCLE_POINT/split/regrid-xy
            outputDir = $CYLC_WORKFLOW_SHARE_DIR/shards/ts/regrid-xy
            component = $CYLC_TASK_PARAM_regrid
            use_subdirs = 1
{% endif %}

{% if DO_NATIVE %}
    [[rename-split-to-pp-native<native>]]
        inherit = RENAME-SPLIT-TO-PP-NATIVE, <native>
    {% if DO_STATICS %}
    [[rename-split-to-pp-native<native_static>]]
        inherit = RENAME-SPLIT-TO-PP-NATIVE, <native_static>
        [[[environment]]]
            component = $CYLC_TASK_PARAM_native_static
    {% endif %}
{% endif %}

{% if DO_REGRID %}
    [[rename-split-to-pp-regrid<regrid>]]
        inherit = RENAME-SPLIT-TO-PP-REGRID, <regrid>
    {% if DO_STATICS %}
    [[rename-split-to-pp-regrid<regrid_static>]]
        inherit = RENAME-SPLIT-TO-PP-REGRID, <regrid_static>
        [[[environment]]]
            component = $CYLC_TASK_PARAM_regrid_static
    {% endif %}
{% endif %}

    [[REMAP-PP-COMPONENTS]]
        script = rose task-run --verbose --app-key remap-pp-components
        [[[environment]]]
            components = $CYLC_TASK_PARAM_component

    [[REMAP-PP-COMPONENTS-TS]]
        inherit = REMAP-PP-COMPONENTS
        [[[environment]]]
            inputDir = $CYLC_WORKFLOW_SHARE_DIR/shards/ts
            outputDir = {{ PP_DIR }}
            product = ts
            dirTSWorkaround = 1
    [[REMAP-PP-COMPONENTS-TS-{{ PP_CHUNK_A }}]]
        inherit = REMAP-PP-COMPONENTS-TS
        [[[environment]]]
            begin = $(cylc cycle-point --offset=-{{ PP_CHUNK_A | subtract_durations(HISTORY_SEGMENT) }})
            currentChunk = {{ PP_CHUNK_A }}
    [[remap-pp-components-ts-{{ PP_CHUNK_A }}<component>]]
        inherit = REMAP-PP-COMPONENTS-TS-{{ PP_CHUNK_A }}, <component>

{% if DO_SECONDARY_PP %}
    [[REMAP-PP-COMPONENTS-TS-{{ PP_CHUNK_B }}]]
        inherit = REMAP-PP-COMPONENTS-TS
        [[[environment]]]
            begin = $(cylc cycle-point --offset=-{{ PP_CHUNK_B | subtract_durations(HISTORY_SEGMENT) }})
            currentChunk = {{ PP_CHUNK_B }}
    [[remap-pp-components-ts-{{ PP_CHUNK_B }}<component>]]
        inherit = REMAP-PP-COMPONENTS-TS-{{ PP_CHUNK_B }}, <component>

{% endif %}

    [[REMAP-PP-COMPONENTS-AV]]
        inherit = REMAP-PP-COMPONENTS
        [[[environment]]]
            inputDir = $CYLC_WORKFLOW_SHARE_DIR/shards/av
            outputDir = $CYLC_WORKFLOW_SHARE_DIR/pp/av
            product = av
    [[REMAP-PP-COMPONENTS-AV-{{ PP_CHUNK_A }}]]
        inherit = REMAP-PP-COMPONENTS-AV
        [[[environment]]]
            begin = $(cylc cycle-point --offset=-{{ PP_CHUNK_A | subtract_durations(HISTORY_SEGMENT) }})
            currentChunk = {{ PP_CHUNK_A }}
    [[remap-pp-components-av-{{ PP_CHUNK_A }}<component>]]
        inherit = REMAP-PP-COMPONENTS-AV-{{ PP_CHUNK_A }}, <component>

{% if DO_SECONDARY_PP %}
    [[REMAP-PP-COMPONENTS-AV-{{ PP_CHUNK_B }}]]
        inherit = REMAP-PP-COMPONENTS-AV
        [[[environment]]]
            begin = $(cylc cycle-point --offset=-{{ PP_CHUNK_B | subtract_durations(HISTORY_SEGMENT) }})
            currentChunk = {{ PP_CHUNK_B }}
    [[remap-pp-components-av-{{ PP_CHUNK_B }}<component>]]
        inherit = REMAP-PP-COMPONENTS-AV-{{ PP_CHUNK_B }}, <component>


{% endif %}

{% if DO_TIMEAVGS %}
    [[COMBINE-TIMEAVGS]]
        script = rose task-run --verbose --app-key combine-timeavgs
        [[[environment]]]
            end = $(cylc cycle-point --print-year)
            outputDir = {{ PP_DIR }}/$CYLC_TASK_PARAM_component/av
    [[COMBINE-TIMEAVGS-{{ PP_CHUNK_A }}]]
        inherit = COMBINE-TIMEAVGS
        [[[environment]]]
            inputDir = $CYLC_WORKFLOW_SHARE_DIR/pp/av
            begin = $(cylc cycle-point --offset=-{{ PP_CHUNK_A | subtract_durations(HISTORY_SEGMENT) }} --print-year)
            currentChunk = {{ PP_CHUNK_A }}
    [[combine-timeavgs-{{ PP_CHUNK_A }}<component>]]
        inherit = COMBINE-TIMEAVGS-{{ PP_CHUNK_A }}, <component>
        [[[environment]]]
            component = $CYLC_TASK_PARAM_component

    {% if DO_SECONDARY_PP %}
    [[COMBINE-TIMEAVGS-{{ PP_CHUNK_B }}]]
        inherit = COMBINE-TIMEAVGS
        [[[environment]]]
            inputDir = $CYLC_WORKFLOW_SHARE_DIR/pp/av
            begin = $(cylc cycle-point --offset=-{{ PP_CHUNK_B | subtract_durations(HISTORY_SEGMENT) }} --print-year)
            currentChunk = {{ PP_CHUNK_B }}
    [[combine-timeavgs-{{ PP_CHUNK_B }}<component>]]
        inherit = COMBINE-TIMEAVGS-{{ PP_CHUNK_B }}, <component>
        [[[environment]]]
            component = $CYLC_TASK_PARAM_component

    {% endif %}
{% endif %}

{% if DO_STATICS %}
    [[remap-pp-components-static]]
        inherit = REMAP-PP-COMPONENTS-TS
        [[[environment]]]
            begin = $CYLC_TASK_CYCLE_POINT
            currentChunk = P0Y
            outputDir = $CYLC_WORKFLOW_SHARE_DIR/pp/static
            components = {{ PP_COMPONENTS }}

            product = static
            dirTSWorkaround = ""
{% endif %}
    [[data-catalog]]
        script = """
        fre catalog builder --overwrite $ppdir $ppdir/catalog
        # workaround to replace P1M with monthly
        sed -i.bak -e 's/,P1M,/,monthly,/' $ppdir/catalog.csv
        """
        [[[environment]]]
          ppdir = {{PP_DIR}}


    [[MAKE-TIMESERIES]]
        pre-script = mkdir -p $outputDir
        script = rose task-run --verbose --app-key make-timeseries
        [[[environment]]]
            fail_ok_components = grid_spec lumip_Lyr lumip_Lyr_crp lumip_Lyr_psl lumip_Lyr_pst

{% if DO_NATIVE %}
    [[MAKE-TIMESERIES-NATIVE]]
        [[[environment]]]
            inputDir = $CYLC_WORKFLOW_SHARE_DIR/shards/ts/native
            outputDir = $CYLC_WORKFLOW_SHARE_DIR/shards/ts/native
            component = $CYLC_TASK_PARAM_native
{% endif %}

{% if DO_REGRID %}
    [[MAKE-TIMESERIES-REGRID]]
        [[[environment]]]
            inputDir = $CYLC_WORKFLOW_SHARE_DIR/shards/ts/regrid-xy
            outputDir = $CYLC_WORKFLOW_SHARE_DIR/shards/ts/regrid-xy
            component = $CYLC_TASK_PARAM_regrid
            use_subdirs = 1
{% endif %}

    [[MAKE-TIMESERIES-{{ PP_CHUNK_A }}]]
        [[[environment]]]
            begin = $(cylc cycle-point --offset=-{{ PP_CHUNK_A | subtract_durations(HISTORY_SEGMENT) }})
            inputChunk = {{ HISTORY_SEGMENT }}
            outputChunk = {{ PP_CHUNK_A }}
{% if DO_NATIVE %}
    [[MAKE-TIMESERIES-NATIVE-{{ PP_CHUNK_A }}]]
        inherit = MAKE-TIMESERIES, MAKE-TIMESERIES-NATIVE, MAKE-TIMESERIES-{{ PP_CHUNK_A }}
    [[make-timeseries-native-{{ PP_CHUNK_A }}<native>]]
        inherit = MAKE-TIMESERIES-NATIVE-{{ PP_CHUNK_A }}, <native>
{% endif %}
{% if DO_REGRID %}
    [[MAKE-TIMESERIES-REGRID-{{ PP_CHUNK_A }}]]
        inherit = MAKE-TIMESERIES, MAKE-TIMESERIES-REGRID, MAKE-TIMESERIES-{{ PP_CHUNK_A }}
    [[make-timeseries-regrid-{{ PP_CHUNK_A }}<regrid>]]
        inherit = MAKE-TIMESERIES-REGRID-{{ PP_CHUNK_A }}, <regrid>
{% endif %}

{% if DO_SECONDARY_PP %}
    [[MAKE-TIMESERIES-{{ PP_CHUNK_B }}]]
        [[[environment]]]
            begin = $(cylc cycle-point --offset=-{{ PP_CHUNK_B | subtract_durations(HISTORY_SEGMENT) }})
            inputChunk = {{ PP_CHUNK_A }}
            outputChunk = {{ PP_CHUNK_B }}
    {% if DO_NATIVE %}
    [[MAKE-TIMESERIES-NATIVE-{{ PP_CHUNK_B }}]]
        inherit = MAKE-TIMESERIES, MAKE-TIMESERIES-NATIVE, MAKE-TIMESERIES-{{ PP_CHUNK_B }}
    [[make-timeseries-native-{{ PP_CHUNK_B }}<native>]]
        inherit = MAKE-TIMESERIES-NATIVE-{{ PP_CHUNK_B }}, <native>
    {% endif %}

    {% if DO_REGRID %}
    [[MAKE-TIMESERIES-REGRID-{{ PP_CHUNK_B }}]]
        inherit = MAKE-TIMESERIES, MAKE-TIMESERIES-REGRID, MAKE-TIMESERIES-{{ PP_CHUNK_B }}
    [[make-timeseries-regrid-{{ PP_CHUNK_B }}<regrid>]]
        inherit = MAKE-TIMESERIES-REGRID-{{ PP_CHUNK_B }}, <regrid>
    {% endif %}
{% endif %}

{% if DO_REGRID %}
    [[REGRID-XY]]
        pre-script = mkdir -p $outputDir
        script = rose task-run --verbose --app-key regrid-xy
        [[[environment]]]
            inputDir = $CYLC_WORKFLOW_SHARE_DIR/cycle/$CYLC_TASK_CYCLE_POINT/history/native
            outputDir = $CYLC_WORKFLOW_SHARE_DIR/cycle/$CYLC_TASK_CYCLE_POINT/history/regrid-xy
            begin = $CYLC_TASK_CYCLE_POINT
            fregridRemapDir = $CYLC_WORKFLOW_SHARE_DIR/fregrid-remap-files
            source = $CYLC_TASK_PARAM_regrid
            gridSpec = {{ PP_GRID_SPEC }}
            defaultxyInterp = {{ PP_DEFAULT_XYINTERP }}
    [[regrid-xy<regrid>]]
        inherit = REGRID-XY, <regrid>
    {% if DO_STATICS %}
    [[regrid-xy<regrid_static>]]
        inherit = REGRID-XY, <regrid_static>
        [[[environment]]]
            source = $CYLC_TASK_PARAM_regrid_static

    {% endif %}
{% endif %}

{% if DO_STATICS %}
    [[combine-statics]]
        pre-script = mkdir -p $outputDir
        [[[environment]]]
            inputDir = $CYLC_WORKFLOW_SHARE_DIR/pp/static
            outputDir = {{ PP_DIR }}
{% endif %}

{% if DO_ANALYSIS %}
    [[ANALYSIS]]
        # Increase time limit for analysis jobs to 24 hours
        execution time limit = PT24H
        pre-script = """
            env
            mkdir -p $outputDir $out_dir
            rose task-run --verbose --app-key analysis
        """
        [[[environment]]]
            # internally-used vars
            outputDir = $CYLC_WORKFLOW_SHARE_DIR/analysis-scripts
            FRE_ANALYSIS_HOME = {{ FRE_ANALYSIS_HOME }}
            FRE_ANALYSIS_GIT_URL = file:///home/fms/local/opt/fre-analysis/git
            # fre-analysis template vars
            yr2 = $(cylc cycle-point --template=CCYY)
            out_dir = {{ ANALYSIS_DIR }}
            descriptor = {{ EXPERIMENT }}
            fremodule = fre/test
            WORKDIR = $TMPDIR/{{ EXPERIMENT }}/{{ PLATFORM }}-{{ TARGET }}/$CYLC_TASK_CYCLE_POINT
            hist_dir = {{ HISTORY_DIR }}
            gridspecfile = {{ PP_GRID_SPEC }}
            # new template vars
            catalog = {{ PP_DIR }}/catalog.json
    {% if DO_SECONDARY_PP %}
{{ 'per-interval-task-definitions' | get_analysis_info(PP_COMPONENTS, PP_DIR, PP_START, PP_STOP, ANALYSIS_START, ANALYSIS_STOP, PP_CHUNK_B, False, DO_ANALYSIS) }}
{{ 'cumulative-task-definitions' | get_analysis_info(PP_COMPONENTS, PP_DIR, PP_START, PP_STOP, ANALYSIS_START, ANALYSIS_STOP, PP_CHUNK_B, False, DO_ANALYSIS) }}
{{ 'defined-interval-task-definitions' | get_analysis_info(PP_COMPONENTS, PP_DIR, PP_START, PP_STOP, ANALYSIS_START, ANALYSIS_STOP, PP_CHUNK_B, False, DO_ANALYSIS) }}
    {% else %}
{{ 'per-interval-task-definitions' | get_analysis_info(PP_COMPONENTS, PP_DIR, PP_START, PP_STOP, ANALYSIS_START, ANALYSIS_STOP, PP_CHUNK_A, False, DO_ANALYSIS) }}
{{ 'cumulative-task-definitions' | get_analysis_info(PP_COMPONENTS, PP_DIR, PP_START, PP_STOP, ANALYSIS_START, ANALYSIS_STOP, PP_CHUNK_A, False, DO_ANALYSIS) }}
{{ 'defined-interval-task-definitions' | get_analysis_info(PP_COMPONENTS, PP_DIR, PP_START, PP_STOP, ANALYSIS_START, ANALYSIS_STOP, PP_CHUNK_A, False, DO_ANALYSIS) }}
    {% endif %}
{% endif %}

{% if DO_MDTF %}
    [[mdtf]]
        pre-script = mkdir -p $MDTF_TMPDIR
        [[[environment]]]
            MDTF_TMPDIR = $CYLC_WORKFLOW_SHARE_DIR/mdtf
{% endif %}

    [[CLEAN]]
        pre-script = "set -x"
        # find commands can fail if the files change underneath, even if the change
        # is not the files that are desired. e.g. we are cleaning year 2000 and year 1999
        # was removed/cleaned half-way through. The find will fail.
        # It would be best to ignore the missing files, but retrying will help.
        execution retry delays = PT5M, PT10M, PT15M

    [[clean-history-native]]
        inherit = CLEAN
        script = "rm -rf $CYLC_WORKFLOW_SHARE_DIR/cycle/$CYLC_TASK_CYCLE_POINT/history/native"

{% if DO_REGRID %}
    [[clean-history-regrid-xy]]
        inherit = CLEAN
        script = "rm -rf $CYLC_WORKFLOW_SHARE_DIR/cycle/$CYLC_TASK_CYCLE_POINT/history/regrid-xy"
{% endif %}

{% if DO_STATICS %}
    [[clean-pp-statics]]
        inherit = CLEAN
        script = "rm -rf $CYLC_WORKFLOW_SHARE_DIR/pp/static"
{% endif %}
{% if DO_NATIVE %}
    [[clean-split-native]]
        inherit = CLEAN
        script = "rm -rf $CYLC_WORKFLOW_SHARE_DIR/cycle/$CYLC_TASK_CYCLE_POINT/split/native"
{% endif %}
{% if DO_REGRID %}
    [[clean-split-regrid-xy]]
        inherit = CLEAN
        script = "rm -rf $CYLC_WORKFLOW_SHARE_DIR/cycle/$CYLC_TASK_CYCLE_POINT/split/regrid-xy"
{% endif %}

{% if DO_STATICS %}
    [[clean-shards-static]]
        inherit = CLEAN
        script = """
            rm -rf $CYLC_WORKFLOW_SHARE_DIR/shards/ts/native/*/P0Y
    {% if DO_REGRID %}
            rm -rf $CYLC_WORKFLOW_SHARE_DIR/shards/ts/regrid-xy/*/*/P0Y
    {% endif %}
        """
{% endif %}

    [[clean-shards-{{ HISTORY_SEGMENT }}]]
        inherit = CLEAN
        script = """
            dirs="$CYLC_WORKFLOW_SHARE_DIR/shards/ts/native/*/*/{{ HISTORY_SEGMENT }} $CYLC_WORKFLOW_SHARE_DIR/shards/ts/regrid-xy/*/*/*/{{ HISTORY_SEGMENT }}"
            for dir in $dirs; do
                if ls $dir; then
{% for SEGMENT in range(0, HIST_SEGMENTS_PER_CHUNK_A) %}
                    find $dir -type f -name "*.*-$(cylc cycle-point --template CCYY --offset={{ HISTORY_SEGMENT | multiply_duration(-SEGMENT) }})*.nc" -print -delete
{% endfor %}
                fi
            done
        """

    [[clean-shards-{{ PP_CHUNK_A }}]]
        inherit = CLEAN
        script = """
            dirs="$CYLC_WORKFLOW_SHARE_DIR/shards/*/native/*/*/{{ PP_CHUNK_A }} $CYLC_WORKFLOW_SHARE_DIR/shards/*/regrid-xy/*/*/*/{{ PP_CHUNK_A }}"
            for dir in $dirs; do
                if ls $dir; then
{% if DO_SECONDARY_PP %}
    {% for CHUNK in range(0, CHUNK_AS_PER_CHUNK_B) %}
                    if [[ {{ PP_CHUNK_A }} == P1Y ]]; then
                        find $dir -type f -name "*.$(cylc cycle-point --template CCYY   --offset={{ PP_CHUNK_A | multiply_duration(-CHUNK) }})*.nc" -print -delete
                    else
                        find $dir -type f -name "*.*-$(cylc cycle-point --template CCYY --offset={{ PP_CHUNK_A | multiply_duration(-CHUNK) }})*.nc" -print -delete
                    fi
    {% endfor %}
{% else %}
                    if [[ {{ PP_CHUNK_A }} == P1Y ]]; then
                        find $dir -type f -name "*.$(cylc cycle-point --template CCYY)*.nc" -print -delete
                    else
                        find $dir -type f -name "*.*-$(cylc cycle-point --template CCYY)*.nc" -print -delete
                    fi
{% endif %}
                fi
            done
        """

{% if DO_SECONDARY_PP %}
    [[clean-shards-{{ PP_CHUNK_B }}]]
        inherit = CLEAN
        script = """
            dirs="$CYLC_WORKFLOW_SHARE_DIR/shards/*/native/*/*/{{ PP_CHUNK_B }} $CYLC_WORKFLOW_SHARE_DIR/shards/*/regrid-xy/*/*/*/{{ PP_CHUNK_B }}"
            for dir in $dirs; do
                if ls $dir; then
                    find $dir -type f -name "*.*-$(cylc cycle-point --template CCYY)*.nc" -print -delete
                fi
            done
        """
{% endif %}

    [[clean-pp-timeavgs-{{ PP_CHUNK_A }}]]
        inherit = CLEAN
        script = """
            dirs=$CYLC_WORKFLOW_SHARE_DIR/pp/av/*/*/{{ PP_CHUNK_A }}
            for dir in $dirs; do
                if ls $dir; then
                    if [[ {{ PP_CHUNK_A }} == P1Y ]]; then
                        find $dir -type f -name "*.$(cylc cycle-point   --template CCYY)*.nc" -print -delete
                    else
                        find $dir -type f -name "*.*-$(cylc cycle-point --template CCYY)*.nc" -print -delete
                    fi
                fi
            done
        """

{% if DO_SECONDARY_PP %}
    [[clean-pp-timeavgs-{{ PP_CHUNK_B }}]]
        inherit = CLEAN
        script = """
            dirs=$CYLC_WORKFLOW_SHARE_DIR/pp/av/*/*/{{ PP_CHUNK_B }}
            for dir in $dirs; do
                if ls $dir; then
                    find $dir -type f -name "*.*-$(cylc cycle-point --template CCYY)*.nc" -print -delete
                fi
            done
        """
{% endif %}



# Site-specific settings
{% include 'site/' ~ SITE ~ '.cylc' %}

{# this is required for portability should probably only include #}
{# inherit = <some_task_param> if SITE = ppan_test #}
{# but empty task-family inheritence is inconsequential for now. #}
{% if SITE != 'ppan_test' %}
    {% if DO_REGRID %}
    [[<regrid>]]
        {% if DO_STATICS %}
    [[<regrid_static>]]
        {% endif %}
    {% endif %}
    {% if DO_NATIVE %}
    [[<native>]]
        {% if DO_STATICS %}
    [[<native_static>]]
        {% endif %}
    {% endif %}
    [[<component>]]
    [[PP-STARTER]]
{% endif %}
