#!jinja2

{# fre version should be programatically set, not hard-coded. #}
{% set FRE_VERSION = 2025.04 %}

{# things written between hash and single braces is a Jinja comment. #}
{# Jinja code between single braces is run.                          #}
{# Jinja code with two braces is printed.                            #}

{# The site-specific file (stored in site/ subdir) is included at the end of this file. When working in the main   #}
{# branch, the ppan site file should be specified. The ppan site comprises of gfdl specific tools. Other available #}
{# sites include ppan, gfdl-ws, and generic. The generic.cylc site file is used for a portable flow.cylc.          #}
{# (Probably, we should use similar mechanisms where sensible, e.g. for shared items among workflows)              #}
{% set SITE = SITE %}

{# Set ANALYSIS_START and ANALYSIS_STOP if they do not exist #}
{% if ANALYSIS_START is not defined %}
    {% set ANALYSIS_START = PP_START %}
{% endif %}
{% if ANALYSIS_STOP is not defined %}
    {% set ANALYSIS_STOP = PP_STOP %}
{% endif %}

{# The combined yaml is the definitive configuration source #}
{% set YAML = EXPERIMENT + '.yaml' %}

{# Retrieve active pp components from the yaml #}
{% set PP_COMPONENTS = YAML | get_components %}

[meta]
    title = "Postprocessing Example 1"
    description = """
    Postprocessing example that includes Bronx-like functionality,
    """
    URL = https://gitlab.gfdl.noaa.gov/fre2/workflows/postprocessing

[scheduler]
    {# Implicit tasks are tasks without explicit runtime definitions in [runtime], often typos. #}
    {# (For prototyping and graphing, change this to True.)                                     #}
    allow implicit tasks = False

    {# Configure the directories and files to be included in the remote file installation #}
    install = app/*, bin/*, etc/*, lib/*
    UTC mode = True

    [[events]]
        # When the stall timeout is reached, a stalled workflow will exit
        # and remove the /xtmp working directory.
        stall timeout = P1W

[task parameters]
{# The task parameters (except for component) depend on configuration in Rose apps,                            #}
{# so custom Jinja triggers are used to form the lists. Cylc and custom Jinja triggers have these rules:       #}
{# 1. Triggers live in Jinja2Filters/ and must be python                                       #}
{# 2. The trigger filename must be <trigger-name>.py                                           #}
{# 3. In the file, trigger must be defined as a function with the same name                    #}
{# 4. First argument is passed through as a pipe, and the rest are passed through in the trigger arguments.    #}
{# More info:                                                      #}
{# The python loaded within Cylc has access to some useful Cylc utilities (e.g. metomi.isodatetime.parsers).   #}
{# For development/testing, use "module load conda; conda activate cylc". Then the Cylc python will be loaded. #}
{% set REGRID  =  "regrid-xy" | form_task_parameters('temporal', PP_COMPONENTS, YAML) %}
{% set REGRID_STATIC  =  "regrid-xy" | form_task_parameters('static', PP_COMPONENTS, YAML) %}

{% set DO_REGRID = REGRID|length %}
{% set DO_REGRID_STATIC = REGRID_STATIC|length %}

{% if DO_REGRID %}
    regrid = {{ REGRID }}
{% endif %}

{% if DO_REGRID_STATIC %}
    regrid_static = {{ REGRID_STATIC }}
{% endif %}

{% set NATIVE  =  "native" | form_task_parameters('temporal', PP_COMPONENTS, YAML) %}
{% set NATIVE_STATIC  =  "native" | form_task_parameters('static', PP_COMPONENTS, YAML) %}

{% set DO_NATIVE = NATIVE|length %}
{% set DO_NATIVE_STATIC = NATIVE_STATIC|length %}

{% if DO_NATIVE %}
    native = {{ NATIVE }}
{% endif %}

{% if DO_NATIVE_STATIC %}
    native_static = {{ NATIVE_STATIC }}
{% endif %}

    {# Standard Jinja2 triggers are also available (e.g. "replace") #}
    component = {{ PP_COMPONENTS | replace(' ', ', ') }}



[scheduling]
    initial cycle point = {{ PP_START }}
    final cycle point = {{ PP_STOP }}
    # max number of active cycle points (default 5)
    # this should be something sensible assuming tasks with required outputs
    # (i.e. not marked as "ok to fail") such as analysis scripts.
    # But until the analysis scripts can be marked optional then a workaround
    # is to set this to be very high, ~100 cycle points.
    # However, the cost of keeping many cycle points active at once are starting
    # stage-history tasks first, possibly filling /xtmp before the clean tasks run.
    runahead limit = P20
    [[queues]]
        # Limit the entire workflow to 100 active tasks. Only allow a single cleaning
        # or data-catalog task to run at once, as they can fail if run in parallel.
        [[[default]]]
            limit = 100
        [[[clean]]]
            limit = 1
            members = CLEAN
        [[[data-catalog]]]
            limit = 1
            members = DATA-CATALOG
    {# Graph strings are organized by recurrence interval-- when to run the tasks.    #}
    {# Currently, we use 4 intervals: every history-file segment, once (for statics), #}
    {# every chunk-a, and every chunk-b.                                              #}
    [[graph]]
{% if DO_ANALYSIS_ONLY %}
    {{ YAML | get_analysis_info('task-graph', PP_COMPONENTS, PP_DIR, PP_START, PP_STOP, PP_CHUNKS, DO_ANALYSIS_ONLY) }}
{% else %}
        #
        # Recurrence interval: every history-file segment
        #
        {{ HISTORY_SEGMENT }} = """
{# Within a recurrence interval, task dependencies are specified with => (depends on), & (and), and | (or). #}
{# Tasks in a dependency can be single tasks, task families (by convention, in all caps),           #}
{# or "ensembles" expanded by the parameters above.                                                         #}

{# All tasks in the STAGE-HISTORY family (staging history and staging history-refined) are started #}
{# once the pp-starter task succeeds.                                                              #}
pp-starter => STAGE-HISTORY

{# Jinja is useful to include or exclude parts of the configuration. In this case, the lines between              #}
{# if DO_REFINEDIAG and endif are used or not used, depending on the value of DO_REFINEDIAG (in rose-suite.conf). #}
{# All template variables in rose-suite.conf are available as Jinja variables.                    #}
{# If refineDiag generation is desired (DO_REFINEDIAG is True), then add these two task dependencies:         #}
{# 1. All tasks in the REFINE-DIAG task family are started once the stage-history task succeeds.          #}
{# 2. stage-history-refined task is started once all the refineDiag tasks succeed.                                #}
{% if DO_REFINEDIAG %}
stage-history => REFINE-DIAG
REFINE-DIAG:succeed-all => stage-history-refined
{% endif %}

{# If preAnalysis desired (vitals calculations is canonical case), #}
{# start all PRE-ANALYSIS tasks when stage-history succeeds. #}
{% if DO_PREANALYSIS %}
stage-history => PRE-ANALYSIS
{% endif %}

{# If task families are on the left side of the => then a qualifier must be used (e.g. :succeed-all)     #}
{# The angle brackets define the "ensemble" axis, the task paramaters defined above.                     #}
{# The next two lines set the major processing for the native and regrid  #}
{# (horizontal regridding) lists of history files. #}
{# Each history file to be regridded should be regridded once staging is done; then should be split and cataloged    #}
{# (into a standard shards directory set by ISO8601 frequencies ).                       #}
{# Each history file needed for native grid processing is similar, except skipping the regridding.         #}
{% if DO_REGRID %}
STAGE-HISTORY:succeed-all => regrid-xy<regrid> => split-netcdf-regrid<regrid> => rename-split-to-pp-regrid<regrid>
    {% if DO_ATMOS_PLEVEL_MASKING %}
STAGE-HISTORY:succeed-all => mask-atmos-plevel<regrid> => regrid-xy<regrid>
    {% endif %}
{% endif %}

{% if DO_NATIVE %}
STAGE-HISTORY:succeed-all => split-netcdf-native<native> => rename-split-to-pp-native<native>
    {% if DO_ATMOS_PLEVEL_MASKING %}
STAGE-HISTORY:succeed-all => mask-atmos-plevel<native> => split-netcdf-native<native>
    {% endif %}
{% endif %}

{# If HISTORY_DIR_REFINED is set, then use the next 3 lines.              #}
{# Regridding and splitting native history files should not start until the history-refined output is available.   #}
{% if HISTORY_DIR_REFINED is defined %}
    {% if DO_REGRID %}
stage-history-refined => regrid-xy<regrid>
    {% endif %}
    {% if DO_NATIVE %}
stage-history-refined => split-netcdf-native<native>
    {% endif %}
{% endif %}

{# If work-dir cleaning is desired, then remove what should now be safe to remove.                                 #}
{# Once regridded history files are split, then the regridded history files can be removed.            #}
{# Once the split (regridded and native) files are cataloged, then the (not-cataloged) split files can be removed. #}
{% if CLEAN_WORK %}
    {% if DO_REGRID %}
regrid-xy<regrid>                 => clean-history-native
split-netcdf-regrid<regrid>       => clean-history-regrid-xy
rename-split-to-pp-regrid<regrid> => clean-split-regrid-xy
    {% endif %}
    {% if DO_NATIVE %}
split-netcdf-native<native>       => clean-history-native
rename-split-to-pp-native<native> => clean-split-native
    {% endif %}
{% endif %}
"""


        #
        # Recurrence interval R1: run only once. useful for statics.
        #
        R1 = """
{# The static processing is similar to the "every history segment" processing, #}
{# except uses different history file lists. #}
pp-starter => STAGE-HISTORY

{% if DO_REGRID_STATIC %}
STAGE-HISTORY:succeed-all => regrid-xy<regrid_static> => split-netcdf-regrid<regrid_static> => rename-split-to-pp-regrid<regrid_static>
{% endif %}

{% if DO_NATIVE_STATIC %}
STAGE-HISTORY:succeed-all =>                             split-netcdf-native<native_static> => rename-split-to-pp-native<native_static>
{% endif %}

{# After cataloging the regridded and native statics, remap them to pp components as desired #}
{% if DO_NATIVE_STATIC and DO_REGRID_STATIC %}
rename-split-to-pp-regrid<regrid_static> & rename-split-to-pp-native<native_static> => remap-pp-components-static => combine-statics
{% elif DO_NATIVE_STATIC %}
rename-split-to-pp-native<native_static> => remap-pp-components-static => combine-statics
{% elif DO_REGRID_STATIC %}
rename-split-to-pp-regrid<regrid_static> => remap-pp-components-static => combine-statics
{% endif %}

{# Similarly, if the history-refined is used, then don't process until the history-refined staging is done. #}
{% if HISTORY_DIR_REFINED is defined %}
    {% if DO_REGRID_STATIC %}
    stage-history-refined => regrid-xy<regrid_static>
    {% endif %}

    {% if DO_NATIVE_STATIC %}
    stage-history-refined => split-netcdf-native<native_static>
    {% endif %}
{% endif %}

{# If work-dir cleaning is set, then remove what should now be safe to remove. #}
{% if CLEAN_WORK and DO_REGRID_STATIC %}
    regrid-xy<regrid_static> => clean-history-native
    split-netcdf-regrid<regrid_static> => clean-history-regrid-xy
    rename-split-to-pp-regrid<regrid_static> => clean-split-regrid-xy
    remap-pp-components-static => clean-shards-static
    combine-statics => clean-pp-statics
{% endif %}

{% if CLEAN_WORK and DO_NATIVE_STATIC %}
    split-netcdf-native<native_static> => clean-history-native
    rename-split-to-pp-native<native_static> => clean-split-native
    remap-pp-components-static => clean-shards-static
    combine-statics => clean-pp-statics
{% endif %}

"""

{% for chunk in PP_CHUNKS | iter_chunks(HISTORY_SEGMENT, PP_START, PP_STOP) %}
    R1/{{ chunk.cycle_point }} = """
        {% if DO_REGRID %}
            rename-split-to-pp-regrid<regrid>
            {% for SEGMENT in chunk.segments[1:] %}
                & rename-split-to-pp-regrid<regrid>[{{ SEGMENT }}]
            {% endfor %}
            {% if HISTORY_SEGMENT != chunk.chunk_size | string %}
                => make-timeseries-regrid-{{ chunk.chunk_size }}<regrid>
            {% endif %}
            {% if DO_TIMEAVGS and not chunk.is_partial %}
                => make-timeavgs-regrid-{{ chunk.chunk_size }}<regrid>
            {% endif %}
        {% endif %}

        {% if DO_NATIVE %}
            rename-split-to-pp-native<native>
            {% for SEGMENT in chunk.segments[1:] %}
                & rename-split-to-pp-native<native>[{{ SEGMENT }}]
            {% endfor %}
            {% if HISTORY_SEGMENT != chunk.chunk_size | string %}
                => make-timeseries-native-{{ chunk.chunk_size }}<native>
            {% endif %}
            {% if DO_TIMEAVGS and not chunk.is_partial %}
                => make-timeavgs-native-{{ chunk.chunk_size }}<native>
            {% endif %}
        {% endif %}

        {% if DO_REGRID %}
            {{ "regrid-xy" | form_remap_dep('temporal', chunk.chunk_size, PP_COMPONENTS, 'ts', YAML, HISTORY_SEGMENT) }}
            {% if DO_TIMEAVGS and not chunk.is_partial %}
                {{ "regrid-xy" | form_remap_dep('temporal', chunk.chunk_size, PP_COMPONENTS, 'av', YAML, HISTORY_SEGMENT) }}
            {% endif %}
        {% endif %}

        {% if DO_NATIVE %}
            {{ "native" | form_remap_dep('temporal', chunk.chunk_size, PP_COMPONENTS, 'ts', YAML, HISTORY_SEGMENT) }}
            {% if DO_TIMEAVGS and not chunk.is_partial %}
                {{ "native" | form_remap_dep('temporal', chunk.chunk_size, PP_COMPONENTS, 'av', YAML, HISTORY_SEGMENT) }}
            {% endif %}
        {% endif %}

        {% if DO_TIMEAVGS and not chunk.is_partial %}
            remap-pp-components-av-{{ chunk.chunk_size }}<component> => combine-timeavgs-{{ chunk.chunk_size }}<component>
            {% if CLEAN_WORK %}
                COMBINE-TIMEAVGS-{{ chunk.chunk_size }}:succeed-all => clean-pp-timeavgs-{{ chunk.chunk_size }}
            {% endif %}
        {% endif %}

        {% if CLEAN_WORK %}
            REMAP-PP-COMPONENTS-TS-{{ chunk.chunk_size }}:succeed-all => clean-shards-{{ chunk.chunk_size }}
            {% if DO_TIMEAVGS and not chunk.is_partial %}
                REMAP-PP-COMPONENTS-AV-{{ chunk.chunk_size }}:succeed-all => clean-shards-{{ chunk.chunk_size }}
            {% endif %}
        {% endif %}

        REMAP-PP-COMPONENTS-TS-{{ chunk.chunk_size }}:succeed-all
    """

    R1/$ = REMAP-PP-COMPONENTS-TS-{{ chunk.chunk_size }}[{{ chunk.cycle_point }}]:succeed-all => data-catalog-final

    {% if CLEAN_WORK %}
        {% for segment in chunk.segments %}
            R1/{{ segment }} = """
                REMAP-PP-COMPONENTS-TS-{{ chunk.chunk_size }}[{{ chunk.cycle_point }}]:succeed-all
                {% if DO_TIMEAVGS and not chunk.is_partial %}
                    & REMAP-PP-COMPONENTS-AV-{{ chunk.chunk_size }}[{{ chunk.cycle_point }}]:succeed-all
                {% endif %}
                => clean-shards-{{ HISTORY_SEGMENT }}
            """
        {% endfor %}
    {% endif %}
{% endfor %}

#
# Recurrence intervals for analysis tasks
#
    {% if DO_ANALYSIS %}
        {{ YAML | get_analysis_info('task-graph', PP_COMPONENTS, PP_DIR, PP_START, PP_STOP, PP_CHUNKS, DO_ANALYSIS_ONLY) }}
    {% endif %}

{% endif %}

[runtime]
    [[pp-starter]]
        inherit = PP-STARTER
        # NOTE! script must appear *before* [[[enviroment]]] or else
        # the job scripts will have quoting issues
        script = """
            # Returns 0 if ready, 1 if not
            #
            echo Arguments:
            echo "    INFO: trigger: $targetFile"
            echo "    INFO: cycle point: $CYLC_TASK_CYCLE_POINT"
            # Resolve the date strings: YYYY, MM, DD, HH
            IFS='-' read YYYY MM DD << DATES
            $(cylc cycle-point --template CCYY-MM-DD)
            DATES
            HH=$(cylc cycle-point --template hh)
            targetFileResolved=$(echo $targetFile | sed -e "s/YYYY/$YYYY/g" -e "s/MM/$MM/g" -e "s/DD/$DD/g" -e "s/HH/$HH/g")
            echo "    trigger (date expanded): $targetFileResolved"
            # Look for target file
            if ls $targetFileResolved; then
                echo "Target ${targetFileResolved} is ready"
                exit 0
            else
                echo "Error: target ${targetFileResolved} is not ready"
                exit 1
            fi
        """
        [[[environment]]]
            targetFile = {{ HISTORY_DIR }}/YYYYMMDD.nc.tar

    [[STAGE-HISTORY]]
        # Increase time limit for staging jobs to 8 hours
        execution time limit = PT8H
        script = """
            set -euo pipefail

            #Stage the contents of a tarfile to PTMP
            echo Arguments:
            echo "    history dir: $historyDir"
            echo "    ptmp dir: $ptmpDir"
            echo "    cycle point: $CYLC_TASK_CYCLE_POINT"
            echo "    TMPDIR (not used yet): ${TMPDIR:=/tmp}"
            echo Utilities:
            type hsmget
            type cylc
            #Verify history directory exists and is a directory
            if [[ ! -d $historyDir ]]; then
                 echo "Error: Archive directory ${historyDir} does not exist or isnt a directory"
                 exit 1
            fi
            #Verify history file exists
            file=$historyDir/$(cylc cycle-point --template CCYYMMDD).nc.tar
            if ls ${file}; then
                 echo "Going to stage ${file} to PTMP"
            else
                 echo "Error: Could not locate ${file}"
                 exit 1
            fi
            #We want to stage the history files to PTMP without transferring to VFTMP.
            #Calling hsmget on a file with wildcards that doesnt exist does this,
            #e.g. "dummy*" as below, but prints a warning
            if hsmget -v -t -a $historyDir -p $ptmpDir$historyDir -w $TMPDIR$historyDir $(basename -s .tar $file)/dummy\*; then
                 echo "History files in ${file} have been staged to PTMP successfully"
            else
                 echo "Error: Cant stage history files in ${file} to PTMP"
                 exit 1
            fi

            # Finally, link these files to $CYLC_WORKFLOW_SHARE_DIR
            mkdir -p $CYLC_WORKFLOW_SHARE_DIR/cycle/$CYLC_TASK_CYCLE_POINT/history/native
            cd $CYLC_WORKFLOW_SHARE_DIR/cycle/$CYLC_TASK_CYCLE_POINT/history/native
            ln -f $ptmpDir/$historyDir/$(cylc cycle-point --template CCYYMMDD).nc/* . \
                || ln -sf $ptmpDir/$historyDir/$(cylc cycle-point --template CCYYMMDD).nc/* .

            #Data Integrity Checking
            fre -v pp histval --warn --history $ptmpDir$historyDir/$(basename -s .tar $file) --date_string $(cylc cycle-point --template CCYYMMDD)

            # Setup PYTHONPATH and io lists for the data lineage tool
            if [ ! -z "${EPMT_DATA_LINEAGE+x}" ] && [ "$EPMT_DATA_LINEAGE" == "1" ]; then
                export PYTHONPATH=$CYLC_SUITE_DEF_PATH:$PYTHONPATH
                export input_file_list=
                export output_file_list=
                echo "Set PYTHONPATH and created i/o lists"
            fi

            if [ ! -z "${EPMT_DATA_LINEAGE+x}" ] && [ "$EPMT_DATA_LINEAGE" == "1" ]; then
                outputDir=$CYLC_WORKFLOW_SHARE_DIR/cycle/$CYLC_TASK_CYCLE_POINT/history/native

                start_time=$(date +%s)

                for file in $(ls $outputDir); do
                    hash_val=$(/home/Cole.Harvey/.conda/envs/bloom-filter-env/bin/python \
                    -m data_lineage.bloomfilter.HashGen $outputDir/$file)
                    export output_file_list="${output_file_list}$file $hash_val,"
                    echo "[DATA LINEAGE] Added $file to output list with hash_val: $hash_val"
                done

                end_time=$(date +%s)
                duration=$((end_time - start_time))
                echo "Time spent hashing and creating the file list: $duration seconds"

                epmt -v annotate EPMT_DATA_LINEAGE_OUT_PATH="$outputDir/"
                echo "[DATA LINEAGE] Annotated $outputDir/ to EPMT_DATA_LINEAGE_OUT_PATH"

                if [ -n "$output_file_list" ]; then
                    compressed_bytes=$(/home/Cole.Harvey/.conda/envs/bloom-filter-env/bin/python \
                    -m data_lineage.bloomfilter.StringCompression "${output_file_list}")
                    epmt -v annotate EPMT_DATA_LINEAGE_OUT="${compressed_bytes%*,}"
                    echo "[DATA LINEAGE] Annotated output files to EPMT_LINEAGE_OUT"
                fi
            fi

            echo "Natural end of the history file staging"
            exit 0
        """
    [[stage-history]]
        inherit = STAGE-HISTORY
        [[[environment]]]
            historyDir = {{ HISTORY_DIR }}
            ptmpDir = {{ PTMP_DIR }}


{% if HISTORY_DIR_REFINED is defined %}
    [[stage-history-refined]]
        inherit = STAGE-HISTORY
        post-script = """
        """
        [[[environment]]]
            historyDir = {{ HISTORY_DIR_REFINED }}
            ptmpDir = {{ PTMP_DIR }}

{% endif %}

{% if DO_TIMEAVGS %}
    [[MAKE-TIMEAVGS]]
        pre-script = mkdir -p $outputDir
        script = rose task-run --verbose --app-key make-timeavgs
    {% if DO_NATIVE %}
    [[MAKE-TIMEAVGS-NATIVE]]
        [[[environment]]]
            inputDir = $CYLC_WORKFLOW_SHARE_DIR/shards/ts/native
            outputDir = $CYLC_WORKFLOW_SHARE_DIR/shards/av/native
            component = $CYLC_TASK_PARAM_native
    {% endif %}
    {% if DO_REGRID %}
    [[MAKE-TIMEAVGS-REGRID]]
        [[[environment]]]
            inputDir = $CYLC_WORKFLOW_SHARE_DIR/shards/ts/regrid-xy
            outputDir = $CYLC_WORKFLOW_SHARE_DIR/shards/av/regrid-xy
            component = $CYLC_TASK_PARAM_regrid
            use_subdirs = 1
    {% endif %}
    {% for PP_CHUNK in PP_CHUNKS %}
        [[MAKE-TIMEAVGS-{{ PP_CHUNK }}]]
            [[[environment]]]
                interval = {{ PP_CHUNK }}
        {% if DO_NATIVE %}
            [[MAKE-TIMEAVGS-NATIVE-{{ PP_CHUNK }}]]
                inherit = MAKE-TIMEAVGS, MAKE-TIMEAVGS-NATIVE, MAKE-TIMEAVGS-{{ PP_CHUNK }}
            [[make-timeavgs-native-{{ PP_CHUNK }}<native>]]
                inherit = MAKE-TIMEAVGS-NATIVE-{{ PP_CHUNK }}, <native>
        {% endif %}
        {% if DO_REGRID %}
            [[MAKE-TIMEAVGS-REGRID-{{ PP_CHUNK }}]]
                inherit = MAKE-TIMEAVGS, MAKE-TIMEAVGS-REGRID, MAKE-TIMEAVGS-{{ PP_CHUNK }}
            [[make-timeavgs-regrid-{{ PP_CHUNK }}<regrid>]]
                inherit = MAKE-TIMEAVGS-REGRID-{{ PP_CHUNK }}, <regrid>
        {% endif %}
    {% endfor %}
{% endif %}

{% if DO_REFINEDIAG or DO_PREANALYSIS %}
    [[PRE-ANALYSIS]]
        pre-script = """
            env
            set -x
            mkdir -p $work $tempCache $refineDiagDir
            cd $work/$hsmdate
            ls
        """
        [[[environment]]]
            name = {{ EXPERIMENT }}
            rtsxml = no-more-xml
            work = $TMPDIR/work
            tempCache = $TMPDIR/tempCache
            root = $CYLC_WORKFLOW_RUN_DIR
            archive = is-this-needed
            scriptName = $CYLC_TASK_LOG_DIR/job
            oname = $(cylc cycle-point --template CCYYMMDD)
            hsmdate = $oname.nc
            ptmpDir = {{ PTMP_DIR }}/{{ HISTORY_DIR }}
            histDir = {{ HISTORY_DIR }}
            platform = {{ PLATFORM }}
            target = {{ TARGET }}
            segment_months = {{ HISTORY_SEGMENT }}
            basedate = is-this-needed
            gridspec = {{ PP_GRID_SPEC }}
            refineDiagDir = $TMPDIR/history_refineDiag/$hsmdate
            catalog = {{ PP_DIR }}/catalog.json
{% endif %}
{% if DO_REFINEDIAG %}
    [[REFINE-DIAG]]
        inherit = PRE-ANALYSIS
        post-script = """
            cd $refineDiagDir
            if ls *nc; then
                refinedCount=$(ls -1 *nc | wc -l)
            else
                refinedCount=0
            fi
            if [[ $refinedCount > 0 ]]; then
                for file in $(ls -1 *nc); do
                    list_ncvars.csh -st01234 $file |& tee $CYLC_WORKFLOW_SHARE_DIR/refineDiag.log
                done
            else
                echo ERROR: RefineDiag script did not create any NetCDF files as it was expected to do
                exit 1
            fi
            if [[ -f {{ HISTORY_DIR_REFINED }}/$oname.nc.tar ]]; then
                echo "the contents of {{ PTMP_DIR }}/{{ HISTORY_DIR_REFINED }} is..."
                ls {{ PTMP_DIR }}/{{ HISTORY_DIR_REFINED }}
                echo "the contents of {{ PTMP_DIR }}/{{ HISTORY_DIR_REFINED }}/$oname.nc is..."
                ls {{ PTMP_DIR }}/{{ HISTORY_DIR_REFINED }}/$oname.nc
                mv -f * $TMPDIR/modify_refineDiag
                mv -f $TMPDIR/modify_refineDiag/* .
                rm -rf $TMPDIR/modify_refineDiag
            fi
        """
{# The following section executes refineDiag tasks, whether single or multiple refineDiag paths are given #}
{# Create a 'macro' function to reduce code repeat #}
    {% macro exec_refine(script_name) -%}
            inherit = REFINE-DIAG
            script = """
                ls
                echo NOTE: About to source user script
                if csh {{ script_name }}; then
                    echo NOTE: User script exited normally
                else
                    echo ERROR: User script got an error status $?
                    exit 1
                fi
            """
    {%- endmacro %}
{# Use the 'split' function to transform string into an iterable list, including of length 1 #}
    {% set refineDiag_scripts = REFINEDIAG_SCRIPTS.split(' ') %}
    {% for refineDiag_path in refineDiag_scripts %}
            [[refineDiag-{{ refineDiag_path[refineDiag_path.rfind('/')+1:refineDiag_path.rfind('.')] | replace(".", "_") }}]]
        {{ exec_refine(refineDiag_path) }}
    {% endfor %}
{% endif %}

{% if DO_PREANALYSIS and PREANALYSIS_SCRIPT is defined %}
    {% set preanalysis_name = PREANALYSIS_SCRIPT[PREANALYSIS_SCRIPT.rfind('/')+1:PREANALYSIS_SCRIPT.rfind('.')] | replace(".", "_") %}
    [[preAnalysis-{{ preanalysis_name }}]]
        inherit = PRE-ANALYSIS
        script = """
            ls
            echo NOTE: About to source user script
            if csh {{ PREANALYSIS_SCRIPT }}; then
                echo NOTE: User script exited normally
            else
                echo ERROR: User script got an error status $?
                exit 1
            fi
        """
{% endif %}

    [[MASK-ATMOS-PLEVEL]]
        script = rose task-run --verbose --app-key mask-atmos-plevel
        [[[environment]]]
            inputDir = $CYLC_WORKFLOW_SHARE_DIR/cycle/$CYLC_TASK_CYCLE_POINT/history/native
{% if DO_NATIVE %}
    [[mask-atmos-plevel<native>]]
        inherit = MASK-ATMOS-PLEVEL, <native>
        [[[environment]]]
            component = $CYLC_TASK_PARAM_native
{% endif %}
{% if DO_REGRID %}
    [[mask-atmos-plevel<regrid>]]
        inherit = MASK-ATMOS-PLEVEL, <regrid>
        [[[environment]]]
            component = $CYLC_TASK_PARAM_regrid
{% endif %}

    [[SPLIT-NETCDF]]

        [[[environment]]]
            {# $date was used as an input arg in the earlier version of  #}
            {# split-netcdf without getting referenced in the script itself. #}
            {# I think it's a reference to an older script that got removed in #}
            {# the first round of cylc rewrites; keeping it here in case #}
            {# we turn out to need it during the user testing. #}
            date = $CYLC_TASK_CYCLE_POINT

{% if DO_NATIVE %}
    [[SPLIT-NETCDF-NATIVE]]
        inherit = SPLIT-NETCDF
        {# 2025-05-13: removing -c $component -y $YAML until $CYLC_TASK_PARAM_component cycling figured out; new arg for forcing split of all vars #}
        script = fre pp split-netcdf-wrapper -i $inputDir -o $outputDir -s $history_file --split-all-vars
        [[[environment]]]
            inputDir = $CYLC_WORKFLOW_SHARE_DIR/cycle/$CYLC_TASK_CYCLE_POINT/history/native
            outputDir = $CYLC_WORKFLOW_SHARE_DIR/cycle/$CYLC_TASK_CYCLE_POINT/split/native
            history_file = $CYLC_TASK_PARAM_native
{% endif %}

{% if DO_REGRID %}
    [[SPLIT-NETCDF-REGRID]]
        inherit = SPLIT-NETCDF
        {# 2025-05-13: removing -c $component -y $YAML until $CYLC_TASK_PARAM_component cycling figured out; new arg for forcing split of all vars #}
        script = fre pp split-netcdf-wrapper -i $inputDir -o $outputDir -s $history_file --split-all-vars --use-subdirs
        [[[environment]]]
            inputDir = $CYLC_WORKFLOW_SHARE_DIR/cycle/$CYLC_TASK_CYCLE_POINT/history/regrid-xy
            outputDir = $CYLC_WORKFLOW_SHARE_DIR/cycle/$CYLC_TASK_CYCLE_POINT/split/regrid-xy
            history_file = $CYLC_TASK_PARAM_regrid
            use_subdirs = 1
{% endif %}

{% if DO_NATIVE %}
    [[split-netcdf-native<native>]]
        inherit = SPLIT-NETCDF-NATIVE, <native>

    {% if DO_NATIVE_STATIC %}
    [[split-netcdf-native<native_static>]]
        inherit = SPLIT-NETCDF-NATIVE, <native_static>
        [[[environment]]]
            history_file = $CYLC_TASK_PARAM_native_static
    {% endif %}
{% endif %}

{% if DO_REGRID %}
    [[split-netcdf-regrid<regrid>]]
        inherit = SPLIT-NETCDF-REGRID, <regrid>

    {% if DO_REGRID_STATIC %}
    [[split-netcdf-regrid<regrid_static>]]
        inherit = SPLIT-NETCDF-REGRID, <regrid_static>
        [[[environment]]]
            history_file = $CYLC_TASK_PARAM_regrid_static
    {% endif %}
{% endif %}

    [[RENAME-SPLIT-TO-PP]]
        pre-script = mkdir -p $outputDir
        script = rose task-run --verbose --app-key rename-split-to-pp

{% if DO_NATIVE %}
    [[RENAME-SPLIT-TO-PP-NATIVE]]
        inherit = RENAME-SPLIT-TO-PP
        [[[environment]]]
            inputDir = $CYLC_WORKFLOW_SHARE_DIR/cycle/$CYLC_TASK_CYCLE_POINT/split/native
            outputDir = $CYLC_WORKFLOW_SHARE_DIR/shards/ts/native
            component = $CYLC_TASK_PARAM_native
{% endif %}

{% if DO_REGRID %}
    [[RENAME-SPLIT-TO-PP-REGRID]]
        inherit = RENAME-SPLIT-TO-PP
        [[[environment]]]
            inputDir = $CYLC_WORKFLOW_SHARE_DIR/cycle/$CYLC_TASK_CYCLE_POINT/split/regrid-xy
            outputDir = $CYLC_WORKFLOW_SHARE_DIR/shards/ts/regrid-xy
            component = $CYLC_TASK_PARAM_regrid
            use_subdirs = 1
{% endif %}

{% if DO_NATIVE %}
    [[rename-split-to-pp-native<native>]]
        inherit = RENAME-SPLIT-TO-PP-NATIVE, <native>
    {% if DO_NATIVE_STATIC %}
    [[rename-split-to-pp-native<native_static>]]
        inherit = RENAME-SPLIT-TO-PP-NATIVE, <native_static>
        [[[environment]]]
            component = $CYLC_TASK_PARAM_native_static
    {% endif %}
{% endif %}

{% if DO_REGRID %}
    [[rename-split-to-pp-regrid<regrid>]]
        inherit = RENAME-SPLIT-TO-PP-REGRID, <regrid>
    {% if DO_REGRID_STATIC %}
    [[rename-split-to-pp-regrid<regrid_static>]]
        inherit = RENAME-SPLIT-TO-PP-REGRID, <regrid_static>
        [[[environment]]]
            component = $CYLC_TASK_PARAM_regrid_static
    {% endif %}
{% endif %}

    [[REMAP-PP-COMPONENTS]]
        # 'rose task-run' should work, but does not in the fre-cli conda environment (activated by this task)
        script = rose-task-run --verbose --app-key remap-pp-components
        [[[environment]]]
            components = $CYLC_TASK_PARAM_component
            yaml_config = {{ YAML }}

    [[REMAP-PP-COMPONENTS-TS]]
        inherit = REMAP-PP-COMPONENTS
        [[[environment]]]
            inputDir = $CYLC_WORKFLOW_SHARE_DIR/shards/ts
            outputDir = {{ PP_DIR }}
            product = ts
            dirTSWorkaround = 1
    {% for PP_CHUNK in PP_CHUNKS %}
        [[REMAP-PP-COMPONENTS-TS-{{ PP_CHUNK }}]]
            inherit = REMAP-PP-COMPONENTS-TS
            [[[environment]]]
                begin = $(cylc cycle-point)
                currentChunk = {{ PP_CHUNK }}
        [[remap-pp-components-ts-{{ PP_CHUNK }}<component>]]
            inherit = REMAP-PP-COMPONENTS-TS-{{ PP_CHUNK }}, <component>
    {% endfor %}

    [[REMAP-PP-COMPONENTS-AV]]
        inherit = REMAP-PP-COMPONENTS
        [[[environment]]]
            inputDir = $CYLC_WORKFLOW_SHARE_DIR/shards/av
            outputDir = $CYLC_WORKFLOW_SHARE_DIR/pp/av
            product = av

    {% for PP_CHUNK in PP_CHUNKS %}
        [[REMAP-PP-COMPONENTS-AV-{{ PP_CHUNK }}]]
            inherit = REMAP-PP-COMPONENTS-AV
            [[[environment]]]
                begin = $(cylc cycle-point)
                currentChunk = {{ PP_CHUNK }}
        [[remap-pp-components-av-{{ PP_CHUNK }}<component>]]
            inherit = REMAP-PP-COMPONENTS-AV-{{ PP_CHUNK }}, <component>
    {% endfor %}

{% if DO_REGRID_STATIC or DO_NATIVE_STATIC %}
    [[remap-pp-components-static]]
        inherit = REMAP-PP-COMPONENTS-TS
        [[[environment]]]
            begin = $CYLC_TASK_CYCLE_POINT
            currentChunk = P0Y
            outputDir = $CYLC_WORKFLOW_SHARE_DIR/pp/static
            components = {{ PP_COMPONENTS }}
            product = static
            dirTSWorkaround = ""
{% endif %}

    [[DATA-CATALOG]]
        script = data-catalog
	[[[environment]]]
	    PP_DIR = {{ PP_DIR }}
    [[data-catalog-final]]
        inherit = DATA-CATALOG

{% if DO_TIMEAVGS %}
    [[COMBINE-TIMEAVGS]]
        script = rose task-run --verbose --app-key combine-timeavgs
        [[[environment]]]
            begin = $(cylc cycle-point --print-year)
            outputDir = {{ PP_DIR }}/$CYLC_TASK_PARAM_component/av

    {% for PP_CHUNK in PP_CHUNKS %}
        [[COMBINE-TIMEAVGS-{{ PP_CHUNK }}]]
            inherit = COMBINE-TIMEAVGS
            [[[environment]]]
                inputDir = $CYLC_WORKFLOW_SHARE_DIR/pp/av
                currentChunk = {{ PP_CHUNK }}
                end = $(cylc cycle-point --print-year --offset={{ PP_CHUNK | subtract_durations(HISTORY_SEGMENT) }})
        [[combine-timeavgs-{{ PP_CHUNK }}<component>]]
            inherit = COMBINE-TIMEAVGS-{{ PP_CHUNK }}, <component>
            [[[environment]]]
                component = $CYLC_TASK_PARAM_component
    {% endfor %}
{% endif %}

    [[MAKE-TIMESERIES]]
        pre-script = mkdir -p $outputDir
        script = rose task-run --verbose --app-key make-timeseries
        [[[environment]]]
            fail_ok_components = grid_spec lumip_Lyr lumip_Lyr_crp lumip_Lyr_psl lumip_Lyr_pst
            pp_stop = {{ PP_STOP }}

{% if DO_NATIVE %}
    [[MAKE-TIMESERIES-NATIVE]]
        [[[environment]]]
            inputDir = $CYLC_WORKFLOW_SHARE_DIR/shards/ts/native
            outputDir = $CYLC_WORKFLOW_SHARE_DIR/shards/ts/native
            component = $CYLC_TASK_PARAM_native
{% endif %}

{% if DO_REGRID %}
    [[MAKE-TIMESERIES-REGRID]]
        [[[environment]]]
            inputDir = $CYLC_WORKFLOW_SHARE_DIR/shards/ts/regrid-xy
            outputDir = $CYLC_WORKFLOW_SHARE_DIR/shards/ts/regrid-xy
            component = $CYLC_TASK_PARAM_regrid
            use_subdirs = 1
{% endif %}

    {% for PP_CHUNK in PP_CHUNKS %}
        [[MAKE-TIMESERIES-{{ PP_CHUNK }}]]
            [[[environment]]]
                begin = $(cylc cycle-point)
                inputChunk = {{ HISTORY_SEGMENT }}
                outputChunk = {{ PP_CHUNK }}
        {% if DO_NATIVE %}
            [[MAKE-TIMESERIES-NATIVE-{{ PP_CHUNK }}]]
                inherit = MAKE-TIMESERIES, MAKE-TIMESERIES-NATIVE, MAKE-TIMESERIES-{{ PP_CHUNK }}
            [[make-timeseries-native-{{ PP_CHUNK }}<native>]]
                inherit = MAKE-TIMESERIES-NATIVE-{{ PP_CHUNK }}, <native>
        {% endif %}
        {% if DO_REGRID %}
            [[MAKE-TIMESERIES-REGRID-{{ PP_CHUNK }}]]
                inherit = MAKE-TIMESERIES, MAKE-TIMESERIES-REGRID, MAKE-TIMESERIES-{{ PP_CHUNK }}
            [[make-timeseries-regrid-{{ PP_CHUNK }}<regrid>]]
                inherit = MAKE-TIMESERIES-REGRID-{{ PP_CHUNK }}, <regrid>
        {% endif %}
    {% endfor %}

{% if DO_REGRID %}
    [[REGRID-XY]]
        script = """
fre --verbose app regrid \
               --input_dir=$CYLC_WORKFLOW_SHARE_DIR/cycle/$CYLC_TASK_CYCLE_POINT/history/native \
               --output_dir=$CYLC_WORKFLOW_SHARE_DIR/cycle/$CYLC_TASK_CYCLE_POINT/history/regrid-xy \
               --begin=$CYLC_TASK_CYCLE_POINT \
               --remap_dir=$CYLC_WORKFLOW_SHARE_DIR/fregrid-remap-files \
               --source=$source \
               --grid_spec={{ PP_GRID_SPEC }} \
               --tmp_dir=$CYLC_TASK_WORK_DIR \
               --rose_config=$CYLC_WORKFLOW_RUN_DIR/app/regrid-xy/rose-app.conf
        """
        # there may be a race condition that causes the fast jobs to fail
        execution retry delays = 2*PT5M
    [[regrid-xy<regrid>]]
        inherit = REGRID-XY, <regrid>
        [[[environment]]]
            source = $CYLC_TASK_PARAM_regrid
    {% if DO_REGRID_STATIC %}
    [[regrid-xy<regrid_static>]]
        inherit = REGRID-XY, <regrid_static>
        [[[environment]]]
            source = $CYLC_TASK_PARAM_regrid_static
    {% endif %}
{% endif %}

{% if DO_REGRID_STATIC or DO_NATIVE_STATIC %}
    [[combine-statics]]
        pre-script = mkdir -p $outputDir
        script = rose task-run --verbose --app-key combine-statics
        [[[environment]]]
            inputDir = $CYLC_WORKFLOW_SHARE_DIR/pp/static
            outputDir = {{ PP_DIR }}
{% endif %}

{% if DO_ANALYSIS %}
    [[PUBLISH-ANALYSIS]]
        [[[environment]]]
            dora_url = dora.gfdl.noaa.gov
    [[BUILD-ANALYSIS]]
        [[[environment]]]
            ANALYSIS_URL = https://github.com/NOAA-GFDL/analysis-scripts.git
    [[ANALYSIS]]
        # Increase time limit for analysis jobs to 24 hours
        execution time limit = PT24H
        [[[environment]]]
            # internally-used vars
            outputDir = $CYLC_WORKFLOW_SHARE_DIR/legacy-analysis-scripts
            # accepted FRE environment variables
            FRE_ANALYSIS_HOME = /home/fms/local/opt/fre-analysis/test
            FRE_ANALYSIS_GIT_URL = file:///home/fms/local/opt/fre-analysis/git
            FRE_ANALYSIS_ARCHIVE = /archive/fms/fre-analysis/test
            # fre-analysis template vars
            yr2 = $(cylc cycle-point --template=CCYY)
            out_dir = {{ ANALYSIS_DIR }}
            descriptor = {{ EXPERIMENT }}
            fremodule = fre/{{ FRE_VERSION }}
            WORKDIR = $TMPDIR/{{ EXPERIMENT }}/{{ PLATFORM }}-{{ TARGET }}/$CYLC_TASK_CYCLE_POINT
            hist_dir = {{ HISTORY_DIR }}
            gridspecfile = {{ PP_GRID_SPEC }}
            # new template vars
            catalog = {{ PP_DIR }}/catalog.json
            experiment_yaml = $CYLC_WORKFLOW_RUN_DIR/{{ EXPERIMENT }}.yaml
    {{ YAML | get_analysis_info('task-definitions', PP_COMPONENTS, PP_DIR, PP_START, PP_STOP, PP_CHUNKS, False ) }}
{% endif %}

    [[CLEAN]]
        pre-script = "set -x"

    [[clean-history-native]]
        inherit = CLEAN
        script = "rm -rf $CYLC_WORKFLOW_SHARE_DIR/cycle/$CYLC_TASK_CYCLE_POINT/history/native"

{% if DO_REGRID %}
    [[clean-history-regrid-xy]]
        inherit = CLEAN
        script = "rm -rf $CYLC_WORKFLOW_SHARE_DIR/cycle/$CYLC_TASK_CYCLE_POINT/history/regrid-xy"
{% endif %}

{% if DO_REGRID_STATIC or DO_NATIVE_STATIC %}
    [[clean-pp-statics]]
        inherit = CLEAN
        script = "rm -rf $CYLC_WORKFLOW_SHARE_DIR/pp/static"
{% endif %}
{% if DO_NATIVE %}
    [[clean-split-native]]
        inherit = CLEAN
        script = "rm -rf $CYLC_WORKFLOW_SHARE_DIR/cycle/$CYLC_TASK_CYCLE_POINT/split/native"
{% endif %}
{% if DO_REGRID %}
    [[clean-split-regrid-xy]]
        inherit = CLEAN
        script = "rm -rf $CYLC_WORKFLOW_SHARE_DIR/cycle/$CYLC_TASK_CYCLE_POINT/split/regrid-xy"
{% endif %}

{% if DO_REGRID_STATIC or DO_NATIVE_STATIC %}
    [[clean-shards-static]]
        inherit = CLEAN
        script = """
            rm -rf $CYLC_WORKFLOW_SHARE_DIR/shards/ts/native/*/P0Y
            rm -rf $CYLC_WORKFLOW_SHARE_DIR/shards/ts/regrid-xy/*/*/P0Y
        """
{% endif %}

    [[clean-shards-{{ HISTORY_SEGMENT }}]]
        inherit = CLEAN
        script = """
            dirs="$CYLC_WORKFLOW_SHARE_DIR/shards/ts/native/*/*/{{ HISTORY_SEGMENT }} $CYLC_WORKFLOW_SHARE_DIR/shards/ts/regrid-xy/*/*/*/{{ HISTORY_SEGMENT }}"
            for dir in $dirs; do
                if [[ -d $dir ]]; then
                    find $dir -type f -name "*.$(cylc cycle-point --template CCYY)*-*.nc" -print -delete
                else
                    echo "Skipping '$dir' as it does not exist"
                fi
            done
        """

    {% for PP_CHUNK in PP_CHUNKS %}
        [[clean-shards-{{ PP_CHUNK }}]]
            inherit = CLEAN
            script = """
                dirs="$CYLC_WORKFLOW_SHARE_DIR/shards/*/native/*/*/{{ PP_CHUNK }} $CYLC_WORKFLOW_SHARE_DIR/shards/*/regrid-xy/*/*/*/{{ PP_CHUNK }}"
                for dir in $dirs; do
                    if [[ -d $dir ]]; then
                        if [[ {{ PP_CHUNK }} == P1Y ]]; then
                            find $dir -type f -name "*.$(cylc cycle-point --template CCYY)*.nc" -print -delete
                        else
                            find $dir -type f -name "*.$(cylc cycle-point --template CCYY)*-*.nc" -print -delete
                        fi
                    else
                        echo "Skipping '$dir' as it does not exist"
                    fi
                done
            """

        [[clean-pp-timeavgs-{{ PP_CHUNK }}]]
            inherit = CLEAN
            script = """
                dirs=$CYLC_WORKFLOW_SHARE_DIR/pp/av/*/*/{{ PP_CHUNK }}
                for dir in $dirs; do
                    if [[ {{ PP_CHUNK }} == P1Y ]]; then
                        find $dir -type f -name "*.$(cylc cycle-point --template CCYY)*.nc" -print -delete
                    else
                        find $dir -type f -name "*.$(cylc cycle-point --template CCYY)*-*.nc" -print -delete
                    fi
                done
            """
    {% endfor %}

# Site-specific settings
{% include 'site/' ~ SITE ~ '.cylc' %}

{# this is required for portability should probably only include #}
{# inherit = <some_task_param> if SITE = ppan_test #}
{# but empty task-family inheritence is inconsequential for now. #}
{% if SITE != 'ppan_test' %}
    {% if DO_REGRID %}
    [[<regrid>]]
        {% if DO_REGRID_STATIC %}
    [[<regrid_static>]]
        {% endif %}
    {% endif %}
    {% if DO_NATIVE %}
    [[<native>]]
        {% if DO_NATIVE_STATIC %}
    [[<native_static>]]
        {% endif %}
    {% endif %}
    [[<component>]]
    [[PP-STARTER]]
{% endif %}
