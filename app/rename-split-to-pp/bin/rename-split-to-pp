#!/bin/bash
set -euo pipefail
set -x

#
# Create per-variable timeseries from shards
#

# Link each input file into a canonical directory structure
function process_files {
    path="$1" #subdir or regular inputDir based on case
    if (( $use_subdir_switch )); then
        my_path=$(basename $path)/
    else
        my_path=
    fi
    
    files_processed_count=0
    #$files is defined before process_files is called
    echo $files
    for file in ${files[@]}; do
        echo $file
        # tiled or non-tiled
        if (( $(echo $file | grep -o '\.' | wc -l) == 4 )); then
            date=$(echo $file | cut -d. -f1)
            label=$(echo $file | cut -d. -f2)
            tile=$(echo $file | cut -d. -f3)
            var=$(echo $file | cut -d. -f4)
        else
            date=$(echo $file | cut -d. -f1)
            label=$(echo $file | cut -d. -f2)
            var=$(echo $file | cut -d. -f3)
            tile=""
        fi
        #echo DEBUG: file=$file, date=$date, label=$label, var=$var, tile=$tile

        # Skip the average_DT|T1|T1 vars
        # not sure if they are a problem for they aren't wanted anyway
        if [[ $var =~ average_.. ]]; then
            continue
        fi

        # For now, skip files that can't be opened with cdo
        # almost certainly we don't want them anyhow
        if ! cdo sinfo $file > /dev/null 2>&1; then
            err WARNING: Skipping file that CDO cannot open: $file
            continue
        fi

        # Check for static
        if ncdump -h $file | grep "\b${var}(" | grep time; then
            timesteps=$(cdo ntime $file 2> /dev/null)
            is_static=0
        else
            is_static=1
            timesteps=1
        fi

        # statics and files with one timestamp aren't handled well
        # cdo ntime reports 1 for statics, so need to use another call to distingush
        # the comparisons at line 54 and 59 are very sensitive to (( vs (
        if (( ${timesteps} == 1 )); then
            # one timestep can mean 2 things: either you have a static file 
            # (when frequency and chunksize are both 0)
            # or you are dealing with a timeseries file that has one timestep
            # and you need to look at the time_bnds to get them
            echo $(cdo ndate $file)
            #Counts every variable in the file that has time as a record dimension. For a static file, 
            #this should be 0 or 1; for a timeseries file, this will be greater than 1.
            #This assumes that we will have a record dimension named time - but frankly, 
            #that's an assumption we're already making when we search for time_bnds
            if [ $is_static == 1 ]; then
                #this is the static case - you do not have a second timestep so this is 0
                freq=P0Y
            else
                # this is the timeseries case
                # possibly no good way to get freq/chunksize other than time_bnds
                if ! ncdump -v time_bnds $file; then
                    err WARNING: Skipping timeseries file that has one timestep but no time_bnds for frequency detection
                    continue
                else
                    d1=$(ncdump -t -v time_bnds $file | tail -n 2 | head -n 1 | cut -d, -f1 | sed 's/[";]//g' | sed 's/^ *//' | sed 's/ *$//' | tr ' ' T)
                    d2=$(ncdump -t -v time_bnds $file | tail -n 2 | head -n 1 | cut -d, -f2 | sed 's/[";]//g' | sed 's/^ *//' | sed 's/ *$//' | tr ' ' T)
                    # we do not expect days here (due to -t in ncdump above) but sometimes we get it anyway
                    # it will be days in this case
                    if [[ $d1 =~ ^[0-9\.]+$ ]]; then
                        read freq format < <(get_freq_and_format_from_two_days $d1 $d2)
                    else
                        read freq format < <(get_freq_and_format_from_two_dates $d1 $d2)
                    fi
                    if [[ $freq == "error" ]]; then
                        continue
                    fi
                fi
            fi

        # estimate frequency from the first two timesteps
        else
            cdo_dates_stdout=$(cdo showtimestamp $file 2> /dev/null)
            d1=$(echo $cdo_dates_stdout | awk '{ print $1 }')
            d2=$(echo $cdo_dates_stdout | awk '{ print $2 }')
            if [[ $d1 == "0000-00-00T00:00:00" ]]; then
                err WARNING: Skipping file with t=0 timestamp of zeros: $file
                continue
            fi
            read freq format < <(get_freq_and_format_from_two_dates $d1 $d2)
            if [[ $freq == "error" ]]; then
                continue
            fi
        fi

        # calculate date2 from # timesteps, date1, and frequency
        date1=$(isodatetime $date)
        date2=$(isodatetime --max=$timesteps R$timesteps/$date1/$freq | tail -n 1 )

        # chunksize is the duration of the file
        chunk=$(isodatetime $date1 $(isodatetime $date2 --offset=$freq))
        # Adjustments
        # 1. if the duration is a 365 or 366 days, count it as a year
        # 2. if the duration is ~30days, count it as a month
        # 3. if the duration is 180-185, count it as 6 months
        if [[ $chunk =~ ^P([0-9]+)D$ ]]; then
            if (( ${BASH_REMATCH[1]} > 27 )) && (( ${BASH_REMATCH[1]} < 32 )); then
                echo "NOTE: Promoting $chunk to P1M"
                chunk=P1M
            elif (( ${BASH_REMATCH[1]} > 179)) && (( ${BASH_REMATCH[1]} < 186 )); then
                echo "NOTE: Promoting $chunk to P6M"
                chunk=P6M
            else
                years_int=$(perl -e "print int(${BASH_REMATCH[1]} / 365)")
                years_frac=$(perl -e "print ${BASH_REMATCH[1]} / 365 - $years_int")
                if [[ $(echo "$years_frac < 0.003" | bc) == 1 ]]; then
                    echo "NOTE: promoting $chunk to P${years_int}Y"
                    chunk=P${years_int}Y
                fi
            fi
        fi

        # copy the file to its new name
        if [[ $freq == P0Y ]]; then
            if [[ -n $tile ]]; then
                newfile=$label.$var.$tile.nc
            else
                newfile=$label.$var.nc
            fi
        else
            if [[ -n $tile ]]; then
                newfile=$label.$(isodatetime --print-format=$format $date1 | tr -d T)-$(isodatetime --print-format=$format $date2 | tr -d T).$var.$tile.nc
            else
                newfile=$label.$(isodatetime --print-format=$format $date1 | tr -d T)-$(isodatetime --print-format=$format $date2 | tr -d T).$var.nc
            fi
        fi



        # If in subdir mode, preserve the subdir
        echo "using subdirs: $use_subdirs"
        if (( $use_subdir_switch )); then
            dir=$outputDir/$subdir/$label/$freq/$chunk
        else
            dir=$outputDir/$label/$freq/$chunk
        fi

        mkdir -p $dir
        #using a [[ here breaks the check for a new file in some cases, which breaks
        #the linking step around line 185
        if [[ -f $dir/$newfile ]]; then
            err Output location $dir/$newfile already exists, not overwriting
        else
            if [[ -n $tile ]]; then
                for t in tile1 tile2 tile3 tile4 tile5 tile6; do
                    f=${file/tile1/$t}
                    newf=${newfile/tile1/$t}
                    ln $f $dir/$newf
                    if [[ $freq != P0Y ]]; then
                        fre -v pp ppval --path $dir/$newfile
                    fi
                done
            else
                ln $file $dir/$newfile
                if [[ $freq != P0Y ]]; then
                        fre -v pp ppval --path $dir/$newfile
                fi
            fi
        fi
        files_processed_count=$((files_processed_count+1))
    done
    echo "${files_processed_count} files processed"
    if [ $files_processed_count == 0 ]; then
        echo "Error in rename-split-to-pp: no files in input dir matched requirements for processing!"
        exit 1
    fi
}

source $(dirname ${BASH_SOURCE[0]})/../shared/shared.sh

echo Arguments:
echo "    input dir: $inputDir"
echo "    output dir: $outputDir"
echo "    component: $component"
echo "    use subdirs: ${use_subdirs:=}"
echo Utilities:
type cdo
type ncdump
type ncks
#isodatetime is a cylc utility; cylc needs to be loaded
type isodatetime

# Verify input directory exists and is a directory
if [[ ! -d $inputDir ]]; then
    err "Error: Input directory '${inputDir}' does not exist or isn't a directory"
    exit 1
fi

# Verify output directory exists and is a directory
if [[ ! -d $outputDir ]]; then
    err "Error: Output directory '${outputDir}' does not exist or isn't a directory"
    exit 1
fi

# Assumptions:
# - Format of the file: DATE1.comp.VAR(.tileX).nc
# - Variable is a static if it does not have a time axis. Otherwise,
# - Date1 is taken from the filename
# - If only one time in file, pass for now. Otherwise,
# - Frequency is estimated from the difference between the first two timesteps
# - Date2 is estimated by multiplying the frequency and the number of timesteps
cd $inputDir
shopt -s extglob

# Find and process the input files

if [[ $use_subdirs == "True" ]]; then
    echo "using subdirs"
    use_subdir_switch=1
    for subdir in $(ls); do
        pushd $subdir
        files=$(echo *.$component?(.tile1).+([[:word:]]).nc)
        if [[ $files =~ \* ]]; then
            err No input files
        else
            process_files "$inputDir/$subdir"
        fi
        popd
    done
else
    echo "not using subdirs"
    use_subdir_switch=0
    # target only the tile1 files for efficiency, at the cost of assuming there are 6
    files=$(echo *.$component?(.tile1).+([[:word:]]).nc)

    # Exit if no input files are found
    if [[ $files =~ \* ]]; then
        err ERROR: No input files found
        exit 1
    fi

    process_files "$inputDir"
fi

echo Natural end of the shard renaming
exit 0
